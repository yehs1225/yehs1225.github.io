<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Yeh&#39;s blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Yeh&#39;s blog Atom Feed"><title data-react-helmet="true">[7] Network Flow | Yeh&#x27;s blog</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://your-docusaurus-test-site.com/docs/Algorithm/Algorithm[7]"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="[7] Network Flow | Yeh&#x27;s blog"><meta data-react-helmet="true" name="description" content="The Maximum-Flow Problem"><meta data-react-helmet="true" property="og:description" content="The Maximum-Flow Problem"><link data-react-helmet="true" rel="icon" href="/img/favicon.png"><link data-react-helmet="true" rel="canonical" href="https://your-docusaurus-test-site.com/docs/Algorithm/Algorithm[7]"><link data-react-helmet="true" rel="alternate" href="https://your-docusaurus-test-site.com/docs/Algorithm/Algorithm[7]" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://your-docusaurus-test-site.com/docs/Algorithm/Algorithm[7]" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.f2b17ad4.css">
<link rel="preload" href="/assets/js/runtime~main.53e15555.js" as="script">
<link rel="preload" href="/assets/js/main.e50ce15c.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/favicon.png" alt="My Site Logo" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/favicon.png" alt="My Site Logo" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">My Site</b></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/intro">Notes</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/yehs1225" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">🌜</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">🌞</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_P2Lg"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_rKC_"><div class="sidebar_CW9Y"><nav class="menu thin-scrollbar menu_SkdO"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">Notes Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active hasHref_VCh3" aria-current="page" href="/docs/Algorithm/Algorithm[1]">Algorithm</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[1]">[1]Intro : Some Representative problems</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[2]">[2] Basic of Algorithm Analysis</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[3]">[3]Graphs</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[4_1]">[4.1]Greedy Algorithms - Analysis</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[4_2]">[4.2]Greedy Algorithm - Shortest Path &amp; MST</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[5]">[5]Divide and Conquer</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[6]">[6]Dynamic Programming</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/Algorithm/Algorithm[7]">[7] Network Flow</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[8]">[8] NP and Computational Intractability</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[9]">[9]Approximation Algorithm</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/BasicKnowlege/CSS-RWD切版練習">BasicKnowlege</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/DataStructures/Graph">DataStructures</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/Django/[DJ]Deploy">Django</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/Docker/Docker1基本介紹">Docker</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/JavaScript/JavaScript-this">JavaScript</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/Python/Python_Class">Python</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/Reactjs/React_ES6">Reactjs</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/Tools/Command-Line-and-Vim">Tools</a></div></li></ul></nav></div></aside><main class="docMainContainer_TCnq"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="docItemContainer_vinB"><article><div class="tocCollapsible_jdIR theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_Fzxq">On this page</button></div><div class="theme-doc-markdown markdown"><h1>[7]<!-- --> Network Flow</h1><h2 class="anchor anchorWithStickyNavbar_mojV" id="the-maximum-flow-problem">The Maximum-Flow Problem<a class="hash-link" href="#the-maximum-flow-problem" title="Direct link to heading">​</a></h2><p>生活中常用圖形Graph來描述網路交通問題（transportation networks），其edges可用來攜帶交通量（carry flow），而nodes則扮演路由點（switches）連接不同edges。Network模型當中有幾項組成元素：edges上的capacities，表示可攜帶量；node source產生交通量，node sink吸收交通量；最後是traffic本身，會在edges當中被傳遞。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="flow-networks">Flow Networks<a class="hash-link" href="#flow-networks" title="Direct link to heading">​</a></h4><p>flow network是一有向圖G = （V,E），且有以下特點：</p><ul><li>每條邊都e都有其capacity，為一正數，用Ce表示。</li><li>圖中的點有單一起始點source（s）。</li><li>圖中的點有單一終點sink（t）。</li><li>除了source、sink之外的點稱為internal nodes。</li></ul><p>假設：</p><ol><li>沒有邊流入source；沒有邊流出sink。</li><li>每個node至少都有一edge相鄰。</li><li>所有capacity皆為整數。</li></ol><h4 class="anchor anchorWithStickyNavbar_mojV" id="defining-flow">Defining Flow<a class="hash-link" href="#defining-flow" title="Direct link to heading">​</a></h4><p>定義何謂carry traffic or flow。</p><p>s-t flow 是一function f，映射每一條edge到一個非負實數，f : E-&gt;R+；f(e)代表edge e可攜帶的flow容量。並且flow f 滿足下列兩項特性：</p><ol><li><strong>Capacity Conditions（容量限制）</strong>：在所有E當中的邊e, 皆符合 0 ≤ f(e) ≤ Ce.</li><li><strong>Conservation conditions（守恆）</strong> ：對於除了s、t外的所有點v，所有流進v的邊e Σf(e) = 所有流出v的邊e Σf(e)</li></ol><h4 class="anchor anchorWithStickyNavbar_mojV" id="the-problem">The Problem<a class="hash-link" href="#the-problem" title="Direct link to heading">​</a></h4><p>給定一flow network，一個自然的目標就是安排traffic來最有效率地使用可得資源：</p><blockquote><p>Given : a flow network</p><p>Output：a flow of maximum possible value</p></blockquote><p>觀察這一問題，可以用問題本身的架構去找到s-t flow的上限值。假設將G分為兩集合A和B，使得s∈A；t∈B。那麼可直覺理解當一flow要從s到t，勢必得在某一時刻從A到B，因此會被一條edge的capacity所設定上限。這表示圖形中的每一條 <strong>cut</strong> 會設定flow可能的上限值。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="design-algorithm">Design Algorithm<a class="hash-link" href="#design-algorithm" title="Direct link to heading">​</a></h2><p>初始時，設定f(e) = 0 for all e。</p><p>首先嘗試&quot;push&quot; flow從s到t，path由{(s,u) , (u,v) , (v,t)}組成。挑選最大可通過量20，並更新這些edge的f(e)=20，沒用到的其他兩條就維持0。現在我們的flow值維持在20，這樣是最大可能的值嗎？不!因為可能值是30。問題出在 — 我們目前執著於想要僅用一條ｓ－ｔ路徑直接push完所有flow（在不超過各邊限制下）。</p><p>因此做些改變，我們看(c)當中的虛線部分，push 10從s到v，造成v不守恆（流入20+10；流出20），因此我們 <strong>取消操作(undo)</strong>10從u到v，如此確保v的守恆，但是變成u不守恆（流入20；流出10），因此我們push 10從u到t。</p><p>將上述操作整理一下，可知</p><ul><li>我們可以push <strong>forward</strong> 剩餘可通過流量（leftover），最直覺的作法。</li><li>我們可以push <strong>backward</strong>已經有攜帶流量的邊，來分散不同方向的流量。</li></ul><p><img src="/assets/images/flow1-39593fd0416f07a63ed2d1ace0809e8d.jpg" width="950" height="342"></p><h3 class="anchor anchorWithStickyNavbar_mojV" id="the-residual-graph">The Residual Graph<a class="hash-link" href="#the-residual-graph" title="Direct link to heading">​</a></h3><p>藉由上面可以push forward &amp; backward的特性，我們定義一圖Gf（Residual Graph），並有以下特性：</p><ul><li><p>Gf和G的node 集合會是一樣的。</p></li><li><p>forward edges：e = (u,v) in Gf, 其容量為Ce - f(e)（leftover）。</p><p>因為在e = (u,v) in G中，已有f(e)被使用，因此在Gf會是Ce - f(e)。</p></li><li><p>backward edges : e&#x27; = (v,u) in Gf，其容量為f(e)。</p><p>因為在e = (u,v) in G中，已有f(e)被使用，因此可以 <strong>undo</strong>的量為f(e)。</p></li></ul><p>根據上面定義，我們可以知道在Gf當中的邊數量可能會是G的兩倍，且通常我們會稱residual graph中的capacity為residual capacity，以跟原始G當中的容量capacity做區別。</p><p><img src="/assets/images/flow2-bdcc1b33cc8fc15a84a4c52124c5f09c.jpg" width="977" height="331"></p><h3 class="anchor anchorWithStickyNavbar_mojV" id="augmenting-paths">Augmenting Paths<a class="hash-link" href="#augmenting-paths" title="Direct link to heading">​</a></h3><p>現在我們要確切地定義一條Gf當中可由s-t的flow。</p><ul><li>令P為Gf當中一條simple path s-t，也就是說P不會到同一點超過一次。</li><li>定義bottleneck(P,f)為P當中最小的minimum residual capacity（respect to f）。</li><li>接者我們定義一操作稱為augment(f,P)，其會在G當中產生新的flow f &#x27; 。</li></ul><div class="codeBlockContainer_I0IT language-pseudocode theme-code-block"><div class="codeBlockContent_wNvx pseudocode"><pre tabindex="0" class="prism-code language-pseudocode codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">augment(f,P)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Let b = bottleneck(P,f)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">For each edge (u,v)∈P</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    If e=(u,v) is a forward edge then</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        increase f(e) in G by b</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Else ((u,v) is a backward edge, and let e=(v,u))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        decrease f(e) in G by b</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Endfor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Return f</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="ford-fulkerson-algorithm">Ford-Fulkerson Algorithm<a class="hash-link" href="#ford-fulkerson-algorithm" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_I0IT language-pseudocode theme-code-block"><div class="codeBlockContent_wNvx pseudocode"><pre tabindex="0" class="prism-code language-pseudocode codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">Max-Flow</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Initially f(e)=0 for all e in G</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    While there is an s-t path in the residual graph Gf</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Let P be a simple s-t path in Gf</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        f′ = augment(f,P)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Update f to be f′</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Update the residual graph Gf to be Gf′</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EndWhile</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Return f</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="maximum-flows-and-minimum-cuts">Maximum Flows and Minimum Cuts<a class="hash-link" href="#maximum-flows-and-minimum-cuts" title="Direct link to heading">​</a></h2><p>將G分為兩集合A和B，使得s∈A；t∈B。那麼可直覺理解當一flow要從s到t，勢必得在某一時刻從A到B。正式說法</p><ul><li>s-t cut是點集合V的（A,B）分割(partition)，使得s∈A；t∈B。</li><li>cut (A,B)的容量以c(A,B)表示，指的是加總所有從A流出的邊的flow值：c(A,B) =  Σ(e out of A) Ce（為最粗淺的上界）。</li></ul><p><strong>定理1</strong></p><blockquote><p>令f為任意s-t flow；（A,B）為任意s-t cut。那麼v(f) = f out(A) - f in(A)。v for value。</p></blockquote><p>這個定義比一般的簡單上界更強。可藉由觀察流經cut的flow量測flow值。計算方式為 <strong>總離開A的量 - 總迴旋回（swirls back into）A的量</strong>。</p><p><strong>證明</strong></p><p>根據定義v(f) = f out(s)。假設 f in (s) = 0，當s沒有流入的邊時，我們可以寫成v(f) = f out(s) - f in(s)。因為A當中除了s之外的點v都是中介點，可知f out(v) - f in(v) = 0。最終可以寫成</p><p>ν(f) = v∈A Σ(f out(v) − f in(v))。因為裡面唯一不為0的值就是當node被設為s時。</p><p>試著把等式右邊做修改。考慮一edge e於下面四種情況</p><ol><li><p>e的兩端都在A：f(e)會是加總一次+和一次-的結果，相互抵消。</p></li><li><p>e的尾端在A：+。</p></li><li><p>e的頭部在A：-。</p></li><li><p>e的兩端都不在A：根本就不在加總裡。</p><p>v∈A Σ(f out(v) − f in(v)) = e out of AΣf(e) - e into AΣf(e) = f out(A) - f in(A)</p></li></ol><p><strong>定理2</strong></p><p>延續自定理1。</p><p>因為A、B是相對的關係（流出A的 = 流進B的），因此定裡1可以變成下面：</p><blockquote><p>令f為任意s-t flow；（A,B）為任意s-t cut。那麼v(f) = f in(B) - f out(B)</p></blockquote><p><strong>定理3</strong></p><p>延續自定理1、2。</p><p>若A = V-{t}且B={t}，那麼定理2=v(f) = f in(B) - f out(B) = f in(t) - f out(t)。已假設t沒有流出的值：f out(t)=0，因此我們可以定義flow值等於f in(t)，也就是最後流入sink t的總量。</p><p><strong>定理4</strong></p><blockquote><p>令f為任意s-t flow；（A,B）為任意s-t cut。那麼ν(f) ≤ c(A, B)。</p></blockquote><p><strong>證明</strong></p><p> ν(f) = f out(A) − fin(A)    <strong>[定理1]<!-- --> </strong></p><p>​        ≤ f out(A)                 <strong>[f in(A)≥0]</strong></p><p>​        =  e out of A Σ f(e) </p><p>​        ≤  e out of A Σ Ce     <strong>[容量限制]</strong></p><p>​        = c(A, B)</p><p>定理4看似比定理1薄弱，然而定理4的右手邊為C(A,B)和特定的flow f無關。其意義為 <strong>每一個flow的上限值都被每一個cut的容量所界定</strong>。也就是說：</p><ol><li>給定一G中一s-t cut值C&#x27;，我們可以馬上知道G中不存在一s-t flow可以大於C&#x27;。</li><li>給定一G中一s-t flow值v&#x27;，我們可以馬上知道G中不存在一s-t cut可以大於v&#x27;。</li></ol><h2 class="anchor anchorWithStickyNavbar_mojV" id="analyze-algorithmmax-flow--min-cut">Analyze Algorithm：Max-Flow = Min-Cut<a class="hash-link" href="#analyze-algorithmmax-flow--min-cut" title="Direct link to heading">​</a></h2><p>令f&#x27;表示一Ford-Fulkerson回傳的flow。希望證明f&#x27;是G當中flow的最大可能值。用上一節所討論的方式，欲證明有一s-t cut（A&#x27;,B&#x27;）使得v(f&#x27;) = c（A&#x27; , B&#x27;）。此演算法終止條件是flow f在residual graph Gf中沒有s-t path，這也是唯一需要的特性來證明該f是最大可能值。</p><p><strong>定理1</strong></p><blockquote><p>若 f 是一s-t flow使得沒有s-t path存在於Gf，那麼G當中便存在一s-t cut（A&#x27;,B&#x27;）使得v(f) = c(A&#x27;,B&#x27;)。於是f是G當中最大可能的flow值，且（A&#x27;,B&#x27;）有G當中任意s-t cut的最小容量。</p></blockquote><p><strong>證明</strong></p><p>上面敘述聲稱 「存在一cut滿足一我們想要的特性」。現在要證明cut確實存在。</p><p>令A&#x27; 表示滿足在Gf中有s-v path的所有點v；令B&#x27;表示剩下的點，B&#x27; = V - A&#x27;。參照下圖：</p><ol><li>（A&#x27;,B&#x27;）確實是一s-t cut。s ∈ A&#x27;，因為總是有路徑可從s-s。此外，t ∉ A，因為在residual graph中沒有s-t路徑，因此，t ∈ B&#x27;。</li><li>假設e = (u,v)是G中的一邊，其中u ∈ A&#x27;且v ∈ B&#x27;。我們聲稱f(e) = Ce。若否，e會是Gf當中的forward edge，且因為u ∈ A&#x27;，Gf存在一s-u path，再加上e會在Gf形成s-v path，違反一開始v  ∈ B&#x27;的假設。</li><li>假設G中存在e&#x27; = (u&#x27;,v&#x27;)，其中u&#x27; ∈ B；v&#x27; ∈ A。我們聲稱f(e&#x27;) = 0。若否，e&#x27;會在Gf中造成backward edge e&#x27;&#x27; = (v&#x27;,u&#x27;)，且因為v&#x27; ∈ A&#x27;，在Gf中存在s-v&#x27; path，再加上e&#x27;&#x27;會在Gf形成s-u&#x27; path，違反一開始u&#x27; ∈ B&#x27;的假設。</li></ol><p>根據上面的釐清，可知，f&#x27;吸收了所有flow值（所有流出A&#x27;的邊）；所有流入A&#x27;的邊都是沒用的，結論：</p><p>v(f)  = f out(A&#x27;) - f in(A&#x27;)</p><p>​        = e out of A&#x27; Σ f(e) - e into A&#x27; Σf(e)</p><p>​        = e out of A’ Σ c(e) - 0</p><p>​        = c(A&#x27; , B&#x27;)</p><p><img src="/assets/images/flow3-9e71be72bf925cf3fecf9d2f0b5c5ba0.jpg" width="771" height="516"></p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/yehs1225/yehs1225.github.io/docs/Algorithm/Algorithm[7].md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_foO9"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/Algorithm/Algorithm[6]"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">[6]Dynamic Programming</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/Algorithm/Algorithm[8]"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">[8] NP and Computational Intractability</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#the-maximum-flow-problem" class="table-of-contents__link toc-highlight">The Maximum-Flow Problem</a></li><li><a href="#design-algorithm" class="table-of-contents__link toc-highlight">Design Algorithm</a><ul><li><a href="#the-residual-graph" class="table-of-contents__link toc-highlight">The Residual Graph</a></li><li><a href="#augmenting-paths" class="table-of-contents__link toc-highlight">Augmenting Paths</a></li><li><a href="#ford-fulkerson-algorithm" class="table-of-contents__link toc-highlight">Ford-Fulkerson Algorithm</a></li></ul></li><li><a href="#maximum-flows-and-minimum-cuts" class="table-of-contents__link toc-highlight">Maximum Flows and Minimum Cuts</a></li><li><a href="#analyze-algorithmmax-flow--min-cut" class="table-of-contents__link toc-highlight">Analyze Algorithm：Max-Flow = Min-Cut</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Tzu Hsuan Yeh. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.53e15555.js"></script>
<script src="/assets/js/main.e50ce15c.js"></script>
</body>
</html>