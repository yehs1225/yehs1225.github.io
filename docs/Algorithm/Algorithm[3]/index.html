<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Yeh&#39;s blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Yeh&#39;s blog Atom Feed"><title data-react-helmet="true">[3]Graphs | Yeh&#x27;s blog</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://your-docusaurus-test-site.com/docs/Algorithm/Algorithm[3]"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="[3]Graphs | Yeh&#x27;s blog"><meta data-react-helmet="true" name="description" content="圖形是離散數學中其中一項重要的項目。Graph的基礎介紹在DataStructures中的Graph圖形有介紹過，這裡簡單複習一些接下來會出現的基礎概念及名詞。"><meta data-react-helmet="true" property="og:description" content="圖形是離散數學中其中一項重要的項目。Graph的基礎介紹在DataStructures中的Graph圖形有介紹過，這裡簡單複習一些接下來會出現的基礎概念及名詞。"><link data-react-helmet="true" rel="icon" href="/img/favicon.png"><link data-react-helmet="true" rel="canonical" href="https://your-docusaurus-test-site.com/docs/Algorithm/Algorithm[3]"><link data-react-helmet="true" rel="alternate" href="https://your-docusaurus-test-site.com/docs/Algorithm/Algorithm[3]" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://your-docusaurus-test-site.com/docs/Algorithm/Algorithm[3]" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.f2b17ad4.css">
<link rel="preload" href="/assets/js/runtime~main.53e15555.js" as="script">
<link rel="preload" href="/assets/js/main.e50ce15c.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/favicon.png" alt="My Site Logo" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/favicon.png" alt="My Site Logo" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">My Site</b></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/intro">Notes</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/yehs1225" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">🌜</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">🌞</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_P2Lg"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_rKC_"><div class="sidebar_CW9Y"><nav class="menu thin-scrollbar menu_SkdO"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">Notes Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active hasHref_VCh3" aria-current="page" href="/docs/Algorithm/Algorithm[1]">Algorithm</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[1]">[1]Intro : Some Representative problems</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[2]">[2] Basic of Algorithm Analysis</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/Algorithm/Algorithm[3]">[3]Graphs</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[4_1]">[4.1]Greedy Algorithms - Analysis</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[4_2]">[4.2]Greedy Algorithm - Shortest Path &amp; MST</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[5]">[5]Divide and Conquer</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[6]">[6]Dynamic Programming</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[7]">[7] Network Flow</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[8]">[8] NP and Computational Intractability</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[9]">[9]Approximation Algorithm</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/BasicKnowlege/CSS-RWD切版練習">BasicKnowlege</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/DataStructures/Graph">DataStructures</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/Django/[DJ]Deploy">Django</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/Docker/Docker1基本介紹">Docker</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/JavaScript/JavaScript-this">JavaScript</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/Python/Python_Class">Python</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/Reactjs/React_ES6">Reactjs</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/Tools/Command-Line-and-Vim">Tools</a></div></li></ul></nav></div></aside><main class="docMainContainer_TCnq"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="docItemContainer_vinB"><article><div class="tocCollapsible_jdIR theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_Fzxq">On this page</button></div><div class="theme-doc-markdown markdown"><h1>[3]<!-- -->Graphs</h1><p>圖形是離散數學中其中一項重要的項目。Graph的基礎介紹在DataStructures中的<a href="https://yehs1225.github.io/docs/DataStructures/Graph" target="_blank" rel="noopener noreferrer">Graph圖形</a>有介紹過，這裡簡單複習一些接下來會出現的基礎概念及名詞。</p><p>圖形是一種簡單用來表示成對關係（pairwise）的方法。</p><h5 class="anchor anchorWithStickyNavbar_mojV" id="無向圖undirected-graph-g">無向圖（Undirected graph）: G<a class="hash-link" href="#無向圖undirected-graph-g" title="Direct link to heading">​</a></h5><p>我們用V表示<strong>點</strong>nodes（vertices）的集合；E表示<strong>邊</strong>edges的集合，而每條邊都 <strong>joins</strong> 兩個點；用 Edge e ∈ E表示含有V中兩元素的子集合：e = {u,v} for some u, v ∈ V，並稱u, v 為e的兩個端點（end）。</p><h5 class="anchor anchorWithStickyNavbar_mojV" id="有向圖directed-graph-g">有向圖（Directed graph）: G&#x27;<a class="hash-link" href="#有向圖directed-graph-g" title="Direct link to heading">​</a></h5><p>我們用V表示<strong>點</strong>nodes（vertices）的集合；E&#x27;表示<strong>邊</strong>edges的集合；每個Edge e&#x27; ∈ E&#x27;都表示一個有順序的pair (u,v)，也就是說u,v不可對調，並稱u是邊的頭（head）、 v 為尾（tail），另外，也稱edge e&#x27; 離開點u進入點v。</p><h5 class="anchor anchorWithStickyNavbar_mojV" id="路徑paths--p">路徑Paths : P<a class="hash-link" href="#路徑paths--p" title="Direct link to heading">​</a></h5><p>在G=(V,E)中，有一序列P由v1,v2,....vk組成，其中每一對vi , vi+1都有邊相連。P被稱作從v1到vk的路徑，或稱為v1-vk path。若一路徑除了起點和終點外的其他點都只經過一次，就稱為simple path。</p><h5 class="anchor anchorWithStickyNavbar_mojV" id="connectivity">Connectivity<a class="hash-link" href="#connectivity" title="Direct link to heading">​</a></h5><p>在無向圖中G =（V,E），若每一對（u,v）u,v∈V 都存在一路徑從u到v，則稱作<strong>connected</strong>；在有向圖中G&#x27; =（V,E&#x27;）要定義connectivity則較微妙!因為可能存在u-v path但不存在v-u path，因此定義為：若每一對（u,v）u,v∈V 都存在一路徑從u到v並且存在一路徑從v到u，稱作<strong>strongly connected</strong>。</p><h5 class="anchor anchorWithStickyNavbar_mojV" id="tree">Tree<a class="hash-link" href="#tree" title="Direct link to heading">​</a></h5><p>樹在DataStructures中的<a href="https://yehs1225.github.io/docs/DataStructures/Tree" target="_blank" rel="noopener noreferrer">Tree</a>有介紹過!若一無向圖connected且不包含cycle，就稱為tree。tree就是一種connected graph，刪除任一edge都會使其disconnect。</p><p>G是一含有n個點的無向圖，下面任兩點都保證第三點的發生：</p><ul><li>G is connected</li><li>G doesn&#x27;t contain a cycle</li><li>G has n-1 edges</li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="connected-component">Connected Component<a class="hash-link" href="#connected-component" title="Direct link to heading">​</a></h2><p>將G中所有與s相連（connected）點集合R稱作connected component，除了下面要介紹的BFS、DFS可以找到connected component外，也可以簡單用下面演算法找到：</p><div class="codeBlockContainer_I0IT language-pseudocode theme-code-block"><div class="codeBlockContent_wNvx pseudocode"><pre tabindex="0" class="prism-code language-pseudocode codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">R will consist of nodes to which s has a path</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Initially R = {s}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">While there is an edge (u,v) where u∈R and v∉R</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Add v to R</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">EndWhile</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h5 class="anchor anchorWithStickyNavbar_mojV" id="correctness---集合r最後真的是包含s的connected-component-of-g">correctness :  集合R最後真的是包含s的connected component of G<a class="hash-link" href="#correctness---集合r最後真的是包含s的connected-component-of-g" title="Direct link to heading">​</a></h5><ul><li>所有屬於R的點v都跟s相連 : 可由BFS保證</li><li>所有不屬於R的點w都不跟s相連</li></ul><p>​	<strong>證明</strong>：反證法，有一點w∉R，但跟s相連。因為s∈R且w∉R，在P上必存在第一個不屬於R的點v，且v≠s。也存在一點u連到v，因為點v是第一個不屬於P的點，可知u∈R，上述可得 : 存在一edge (u,v)，其中u∈R且v∉R，此敘述違反演算法中while迴圈的中止條件，矛盾。</p><p><strong>The set of all Connected Component</strong></p><blockquote><p>任何圖中的兩點s和t，他們的connected components要不是相同就是沒交集（disjoint）。</p></blockquote><h5 class="anchor anchorWithStickyNavbar_mojV" id="strongly-connected-component-scc">Strongly Connected Component (<strong>SCC</strong>)<a class="hash-link" href="#strongly-connected-component-scc" title="Direct link to heading">​</a></h5><p>指的是一有向圖中最大的Strongly Connected子圖</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="breadth-fisrst-search-bfs">Breadth-Fisrst-Search (BFS)<a class="hash-link" href="#breadth-fisrst-search-bfs" title="Direct link to heading">​</a></h2><p>當我們要查看Graph G中的兩點s-t是否為connected時，可以嘗試用BFS演算法，以下圖1為例：以1作為s，向外尋找所有可能的方向，每次加入一層（layer），以L0（點1）,L1（點2,3）,L2（點4,5,7,8）,L3（點6）表示。最後除了得到s可到達的點之外，也計算了到達這些點的最短距離。</p><p>*層級也可以算是一種距離的表示方式，例如點2、3距離s都是1。</p><p>其中Layer定義：</p><ul><li>Layer L1包含所有起點s的neighbor（為了符號的統一使用，多數時候會用L0表示僅包含起點s的集合）。</li><li>假設我們已經定義layers L1,...Lj，那麼Lj+1會包含所有前面層級所未包含的點，並且這些點都和Lj有邊相連。</li></ul><p>圖1的G執行完BFS後，就會得到一棵root在s（點1）的BFS tree T，可以轉變成圖2表示，其中實線代表該edge屬於T，且當然也屬於G；虛線則代表edge屬於G，但不屬於T。</p><p><img src="/assets/images/graph_1-9ecf37f3dc229163b5f28c5db018f002.jpg" width="2139" height="783"></p><p><strong>定理</strong> : </p><blockquote><p>T是一BFS tree，點x,y是T中分屬於layer Li和Lj的兩點，且(x,y)是G的一個邊。那麼i和j最多相差1。</p></blockquote><p><strong>證明</strong> : 用反證法證明，假設i, j 相差大於1。</p><p>j&gt;i+1，根據BFS演算法，點x的neighbor要不是在 (a)下一層，要不就是在(b)之前已經走訪過，也就是說j&lt;i，但已假設j&gt;i所以僅(a)成立。(a)成立也就代表j=i+1和j&gt;i+1矛盾。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="implement">Implement<a class="hash-link" href="#implement" title="Direct link to heading">​</a></h3><p>因為BFS要檢查從特定點出發可到達的點（尚未被走過的），因此可以選擇用adjacent list。另外，設一陣列Discovered<!-- -->[n]<!-- -->儲存已走過的點；陣列Li （i=0,1,2,...）儲存在第Li層的點，其中L<!-- -->[i]<!-- -->用stack和queue都可以，因為和順序沒關係。</p><p>O(m+n)</p><div class="codeBlockContainer_I0IT language-pseudocode theme-code-block"><div class="codeBlockContent_wNvx pseudocode"><pre tabindex="0" class="prism-code language-pseudocode codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">BFS(s):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Set Discovered[s] = True and Discovered[v]=False for all other v</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Initialize L[0] to consist of the single element s </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Set the layer counter i=0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Set the current BFS tree T =  ∅</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    While L[i] is not empty</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Initialize an empty list L[i+1]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        For each node u∈L[i] </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Consider each edge (u,v) incident to u</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            If Discovered[v] = false then</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Set Discovered[v]=true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Add edge (u,v) to the tree T</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Add v to the list L[i+1]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            EndIf</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        EndFor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Increment the layer counter i by one</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EndWhile</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="depth-fisrst-search-dfs">Depth-Fisrst-Search (DFS)<a class="hash-link" href="#depth-fisrst-search-dfs" title="Direct link to heading">​</a></h2><p>類似老鼠走迷宮：選定一條可走的邊之後會一直走到走不下去為止，再回頭找到之前沒探索過的點繼續走。</p><div class="codeBlockContainer_I0IT language-pseudocode theme-code-block"><div class="codeBlockContent_wNvx pseudocode"><pre tabindex="0" class="prism-code language-pseudocode codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">DFS(u):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Mark u as &quot;Explored&quot; and add u to R:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    For each edge (u,v) incident to u </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        If v is not marked &quot;Explored&quot; then </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Recursively invoke DFS(v)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        EndIf</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EndFor</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>剛剛圖1（下圖3）若改成DFS，執行過程就會像圖4一樣。</p><p><img src="/assets/images/graph_2-7164b0b2933cdff0ed0975f9a47ac3c4.jpg" width="1758" height="788"></p><p>可觀察到在遞迴呼叫DFS(u)時和遞迴呼叫結束之間的所有點都會是已被標註&quot;Explored&quot;的點（如點u）的後代。</p><p><strong>定理 : </strong> </p><blockquote><p>T是DFS tree，x, y是T中的兩個點且edge(x,y)屬於G但不屬於T。那麼x,y其中一個會是另一個的祖先。</p></blockquote><p><strong>證明 :</strong>  WLOG, 在DFS演算法中，x比y早被走到，當查看與x相連的y時，因為edge(x,y)不屬於T表示y並未被標示成Explored。因為在第一次呼叫DFS(x)時，y未被標記成Explored，代表這個點是在遞迴呼叫DFS(x)和遞迴呼叫結束之間發現的，因此我們可以由上面的觀察知道y是x的後代。</p><p>*WLOG : Without Loss of Generality不失一般性</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="implement-1">Implement<a class="hash-link" href="#implement-1" title="Direct link to heading">​</a></h3><p>用一陣列Explored<!-- -->[n]<!-- -->存走訪過的點；Stack（LIFO）存要被檢查的點。</p><p>O(m+n)</p><div class="codeBlockContainer_I0IT language-pseudocode theme-code-block"><div class="codeBlockContent_wNvx pseudocode"><pre tabindex="0" class="prism-code language-pseudocode codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">DFS(s):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Initialize S to be a stack with one element s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    While S is not empty:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Take a node u from S</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        If Explored[u] = False then</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Set Explored[u] = true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            For each edge(u,v) incident to u</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Add v to the stack S</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            EndFor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        EndIf</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EndWhile</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="bipartiteness">Bipartiteness<a class="hash-link" href="#bipartiteness" title="Direct link to heading">​</a></h2><p>Bipartitie graph （bigraph）G = (X,Y,E) ，G當中的所有點可以被分為兩個集合X, Y，且每一條邊一端點位於X、一端點位於Y。X和Y是兩個不相交的集合。X,Y內的任兩點不相鄰。圖5。</p><p><img src="/assets/images/graph_3-cac5e0b034215d34256452cf61097d81.jpg" width="1415" height="422"></p><blockquote><p>If a graph G is bipartite, then it cannot contain an odd cycle.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_mojV" id="test-bipartiteness">Test Bipartiteness<a class="hash-link" href="#test-bipartiteness" title="Direct link to heading">​</a></h3><p>我們知道bigraph中的每一條邊都連接不同集合的點，想像成將一端點塗為紅色、另一端點塗為藍色，那麼我們可以BFS的演算法來完成：從點s出發，遇到另一點就將其塗為紅色，遇到下一點再塗為藍色，再換回紅色....；或者也可以說是將點s塗為紅色、L1塗為藍色、L2塗為紅色...。</p><p>再查看一次<a href="https://yehs1225.github.io/docs/Algorithm/Algorithm%5B3%5D#implement" target="_blank" rel="noopener noreferrer">一般的BFS演算法</a>。加上陣列Color<!-- -->[v]<!-- -->儲存每一點的顏色，當點v 被加入陣列L<!-- -->[i+1]<!-- -->時，若i+1為偶數則塗成紅色；奇數則塗為藍色，最後我們在檢查每條邊是否兩端都被塗上相異的顏色。時間複雜度和BFS一樣為O(M+N)。</p><div class="codeBlockContainer_I0IT language-pseudocode theme-code-block"><div class="codeBlockContent_wNvx pseudocode"><pre tabindex="0" class="prism-code language-pseudocode codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">BFS(s):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Set Discovered[s] = True and Discovered[v]=False for all other v</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Initialize L[0] to consist of the single element s </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    color[s] = red</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Set the layer counter i=0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Set the current BFS tree T =  ∅</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    While L[i] is not empty</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Initialize an empty list L[i+1]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        For each node u∈L[i] </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Consider each edge (u,v) incident to u</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            If Discovered[v] = false then</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Set Discovered[v]=true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Add edge (u,v) to the tree T</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Add v to the list L[i+1]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                If i+1 is even then</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    color[v]=red</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Else </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    color[v]=blue</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                EndIf</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            EndIf</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        EndFor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Increment the layer counter i by one</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EndWhile</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h5 class="anchor anchorWithStickyNavbar_mojV" id="correctness-">Correctness :<a class="hash-link" href="#correctness-" title="Direct link to heading">​</a></h5><p>G是一connected graph，以s做為起點運用BFS產生layer L1,L2,....。那麼下面至少有一項成立：</p><ul><li>G當中不能有邊上兩點在同一層，使得G為bipartite</li><li>G當中有邊上兩點在同一層，那麼G含有odd-length cycle，使得G不為bipartitie</li></ul><p><strong>第二點證明：</strong></p><p>假設存在一edge(x,y)且x和y屬於同一層 Lj。令z = lca(x,y) <!-- -->[lca : Lowest Common ancestor]<!-- -->且點z位於Li。考慮一cycle : (x-y),(y-z),(z-x)那麼x-z這條路徑長度就是1+(i+j) +(i+j) ，為一odd cycle。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="connectivity-1">Connectivity<a class="hash-link" href="#connectivity-1" title="Direct link to heading">​</a></h2><p>Strong connectivity指在有向圖中存在pair (u,v) 其中有u-v path也有v-u path，也稱u,v是mutually reachable。mutually reachable有一些很棒的特性，且大部分出自下面這個簡單的事實：</p><blockquote><p>若u, v 是mutually reachable，v,w 是mutually reachable，那麼u,w也是mutually reachable</p></blockquote><p><strong>證明 : </strong></p><p><img src="/assets/images/graph_4-d19a887b10c22604fd7015f94579d90a.jpg" width="904" height="278"></p><h3 class="anchor anchorWithStickyNavbar_mojV" id="testing-strong-connectivity">Testing Strong Connectivity<a class="hash-link" href="#testing-strong-connectivity" title="Direct link to heading">​</a></h3><p>是否能以linear time檢查一graph是不是Strong Connectivity？</p><p>白話來說，跑兩次BFS就可以!因此時間也為O(n+m)</p><p>其中Grev為將G中所有edge方向反轉。</p><div class="codeBlockContainer_I0IT language-pseudocode theme-code-block"><div class="codeBlockContent_wNvx pseudocode"><pre tabindex="0" class="prism-code language-pseudocode codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">TestSC(G)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Pick any node s in G</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">R = BFS(s,G)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Rrev = BFS(s,Grev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">If (Grev = V = R) then</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return true </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Else </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return false</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h5 class="anchor anchorWithStickyNavbar_mojV" id="correctness">Correctness<a class="hash-link" href="#correctness" title="Direct link to heading">​</a></h5><p>(1)   Not strongly connected（return false）的正確性：</p><p>以BFS對G及Grev 以點s為起始搜尋，若任一搜尋無法到達每一點，即違反strongly connected的定義，那麼此圖G必定不為strongly connected。</p><p>(2)   strongly connected（return true）的正確性：</p><p>以BFS對G及Grev 以點s為起始搜尋，s可到達每一點且每一點也能到達s，代表s到任一點u是mutually reachable，到任一點v也是mutually reachable，根據上面的定理可得在G中的任一兩點皆為mutually reachable，符合strongly connected的定義。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="directed-acyclic-graphs-and-topological-ordering">Directed Acyclic Graphs and Topological Ordering<a class="hash-link" href="#directed-acyclic-graphs-and-topological-ordering" title="Direct link to heading">​</a></h2><p>Directed Acyclic Graphs 簡稱為DAG，代表一有向圖中不包含cycle。若一無向圖不包含cycle那麼它就有非常簡單的結構，每個connected components都是一棵樹；在有向圖中沒有cycle可能也具有豐富的結構性，例如擁有較多邊的圖（圖7）。</p><p><img src="/assets/images/graph_5-1d03b90a248d8cf4e6721e43a243ec37.jpg" width="1522" height="403"></p><p>DAG可以用來表示 <strong>前後順序關係</strong>或 <strong>依賴性（dependencies）</strong>，是電腦科學中常見的結構，我們可以將圖7編號變成圖8。進一步討論 <strong>前後順序關係</strong>，日常生活中像是修課的順序，需要先完成某項課程才能選修進階課程這樣的作法，必須由較小的點在前往較大的點，稱為<strong>topological ordering</strong>，圖9就是一種，也是圖8所轉換而來的。</p><p><strong>定理 :</strong> </p><blockquote><p>若一graph G為topological ordering，那麼G是一DAG</p></blockquote><p><strong>證明 : </strong></p><p>以反證法證明，G為一topological ordering : v1,v2,...,vk且含有cycle C。令vi為C中擁有最小index的點，vj是vi前的點（有一edge(vj,vi)）。要選擇vi時，代表我們已經選過vj，和G為topological ordering 的假設矛盾。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="q若g為一dag-那麼g會有topological-ordering嗎">Q:若G為一DAG, 那麼G會有topological ordering嗎?<a class="hash-link" href="#q若g為一dag-那麼g會有topological-ordering嗎" title="Direct link to heading">​</a></h4><p><strong>定理1 :</strong></p><blockquote><p>在每一個DAG G中，都至少存在一點沒有流入的邊</p></blockquote><p><strong>證明 : </strong></p><p>用反證法證明，G是一DAG，且每一點都至少有一流入的邊。</p><p>選一點v，因為有回去的邊所以一定可以往回找到一點u，到u之後一定也可以往回找一點x，如此往回找的動作重複n+1次後（一開始找v也算一次），因為總共只有n個點，所以會找回第一個點v，也就代表存在cycle，和DAG的定義矛盾。</p><p>有了定理1就可以回答這個問題。</p><p><strong>定理2 :</strong></p><blockquote><p>If G is a DAG, then G has a topological ordering.</p></blockquote><p><strong>證明 :</strong> </p><p>用歸納法。</p><p>我們可以聲稱 &quot;每一DAG都有topological ordering&quot;，尤其在點個數為1和2時更為顯而易見。現在聲稱在有n個點時仍為真，給定一G有n+1個點，必定能找到一點v沒有流入的邊（定理1），將v放在topological ordering的第一位是可行的，因為v的邊都是流出的，現在G - {v}仍是DAG，因為不會形成cycle（n個點的G本來就沒有），所以我們可以得到topological ordering : G - {v}，並將這些點放在v後面，這些在G當中所有邊都有流向的地方（順序關係），因此這是一個topological ordering。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="compute-a-topological-ordering-of-g">Compute a topological ordering of G<a class="hash-link" href="#compute-a-topological-ordering-of-g" title="Direct link to heading">​</a></h3><p>根據上面的定理，可以設計出下面的演算法。 並且根據此演算法，將上面圖8轉為圖9的過程如下圖10所示。</p><div class="codeBlockContainer_I0IT language-pseudocode theme-code-block"><div class="codeBlockContent_wNvx pseudocode"><pre tabindex="0" class="prism-code language-pseudocode codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">To compute a topological ordering of G:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Find a node v with no incoming edges and order it first</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Delete v from G</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Recursively compute a topological ordering of G−{v} and append this order after v</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><img src="/assets/images/graph_6-f30ac96e0b97484f070af74c14d70589.jpg" width="1340" height="770"></p><h4 class="anchor anchorWithStickyNavbar_mojV" id="時間複雜度">時間複雜度<a class="hash-link" href="#時間複雜度" title="Direct link to heading">​</a></h4><p>找到沒有流入的點v並且自G中刪除需要O(n)的時間，共要執行n次，所以是O(n^2)。當G非常稠密（dense），含有Θ(n^2)個邊時，這樣的時間複雜度對於輸入大小來說是linear；但是當邊(m)的數量大幅小於點(n)的數量，若時間複雜度為O(m+n)會是O(n^2)大幅的改善。</p><p>我們可以藉由「<strong>疊代（iteration）刪除沒有流入的點</strong>」的方式達到O(m+n)。若一點尚未被演算法刪除，宣告為&quot;active&quot;，並且維持下面兩件事：</p><ol><li>對每一點w維持「是從active點流入的邊」的數量</li><li>一集合S包含G中所有「沒有從其他active點流入的邊」的active點</li></ol><p>起初所有點都是active，所以可以很好初始化上面兩點。接者每一疊代都從S挑出一點v並刪除，刪除v後查看所有與v有邊的點w，若邊的流向為v-&gt;w則將w「是從active點流入的邊」的數量減1，當數量為0時，將w加入集合S。藉由這樣的方式，可以持續找到有資格被刪除的點，並且在過程中用constant work在處理邊上。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/yehs1225/yehs1225.github.io/docs/Algorithm/Algorithm[3].md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_foO9"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/Algorithm/Algorithm[2]"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">[2] Basic of Algorithm Analysis</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/Algorithm/Algorithm[4_1]"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">[4.1]Greedy Algorithms - Analysis</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#connected-component" class="table-of-contents__link toc-highlight">Connected Component</a></li><li><a href="#breadth-fisrst-search-bfs" class="table-of-contents__link toc-highlight">Breadth-Fisrst-Search (BFS)</a><ul><li><a href="#implement" class="table-of-contents__link toc-highlight">Implement</a></li></ul></li><li><a href="#depth-fisrst-search-dfs" class="table-of-contents__link toc-highlight">Depth-Fisrst-Search (DFS)</a><ul><li><a href="#implement-1" class="table-of-contents__link toc-highlight">Implement</a></li></ul></li><li><a href="#bipartiteness" class="table-of-contents__link toc-highlight">Bipartiteness</a><ul><li><a href="#test-bipartiteness" class="table-of-contents__link toc-highlight">Test Bipartiteness</a></li></ul></li><li><a href="#connectivity-1" class="table-of-contents__link toc-highlight">Connectivity</a><ul><li><a href="#testing-strong-connectivity" class="table-of-contents__link toc-highlight">Testing Strong Connectivity</a></li></ul></li><li><a href="#directed-acyclic-graphs-and-topological-ordering" class="table-of-contents__link toc-highlight">Directed Acyclic Graphs and Topological Ordering</a><ul><li><a href="#compute-a-topological-ordering-of-g" class="table-of-contents__link toc-highlight">Compute a topological ordering of G</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Tzu Hsuan Yeh. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.53e15555.js"></script>
<script src="/assets/js/main.e50ce15c.js"></script>
</body>
</html>