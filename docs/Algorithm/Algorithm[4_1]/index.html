<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Yeh&#39;s blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Yeh&#39;s blog Atom Feed"><title data-react-helmet="true">[4.1]Greedy Algorithms - Analysis | Yeh&#x27;s blog</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://your-docusaurus-test-site.com/docs/Algorithm/Algorithm[4_1]"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="[4.1]Greedy Algorithms - Analysis | Yeh&#x27;s blog"><meta data-react-helmet="true" name="description" content="Greedy Algorithm貪婪演算法，指的是「當一演算法 以小步驟 去發展解答，並且 每一步驟都以短淺的眼光選擇當下最好的」，基本上任何問題都很容易發展出一個貪婪演算法，因為通常是以直覺的方式想出來，但是這樣的演算法通常無法產生最佳解（not optimal）。因此，在在貪婪演算法中最困難的部份是要證明該演算法為optimal，通常我們以下面兩種方法來證明："><meta data-react-helmet="true" property="og:description" content="Greedy Algorithm貪婪演算法，指的是「當一演算法 以小步驟 去發展解答，並且 每一步驟都以短淺的眼光選擇當下最好的」，基本上任何問題都很容易發展出一個貪婪演算法，因為通常是以直覺的方式想出來，但是這樣的演算法通常無法產生最佳解（not optimal）。因此，在在貪婪演算法中最困難的部份是要證明該演算法為optimal，通常我們以下面兩種方法來證明："><link data-react-helmet="true" rel="icon" href="/img/favicon.png"><link data-react-helmet="true" rel="canonical" href="https://your-docusaurus-test-site.com/docs/Algorithm/Algorithm[4_1]"><link data-react-helmet="true" rel="alternate" href="https://your-docusaurus-test-site.com/docs/Algorithm/Algorithm[4_1]" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://your-docusaurus-test-site.com/docs/Algorithm/Algorithm[4_1]" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.f2b17ad4.css">
<link rel="preload" href="/assets/js/runtime~main.563c7ca5.js" as="script">
<link rel="preload" href="/assets/js/main.d47f52f6.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/favicon.png" alt="My Site Logo" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/favicon.png" alt="My Site Logo" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">My Site</b></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/intro">Notes</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/yehs1225" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">🌜</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">🌞</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_P2Lg"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_rKC_"><div class="sidebar_CW9Y"><nav class="menu thin-scrollbar menu_SkdO"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">Notes Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active hasHref_VCh3" aria-current="page" href="/docs/Algorithm/Algorithm[1]">Algorithm</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[1]">[1]Intro : Some Representative problems</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[2]">[2] Basic of Algorithm Analysis</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[3]">[3]Graphs</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/Algorithm/Algorithm[4_1]">[4.1]Greedy Algorithms - Analysis</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[4_2]">[4.2]Greedy Algorithm - Shortest Path &amp; MST</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[5]">[5]Divide and Conquer</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[6]">[6]Dynamic Programming</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/BasicKnowlege/CSS-RWD切版練習">BasicKnowlege</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/DataStructures/Graph">DataStructures</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/Django/[DJ]Deploy">Django</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/Docker/Docker1基本介紹">Docker</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/JavaScript/JavaScript-this">JavaScript</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/Python/Python_Class">Python</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/Reactjs/React_ES6">Reactjs</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/Tools/Command-Line-and-Vim">Tools</a></div></li></ul></nav></div></aside><main class="docMainContainer_TCnq"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="docItemContainer_vinB"><article><div class="tocCollapsible_jdIR theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_Fzxq">On this page</button></div><div class="theme-doc-markdown markdown"><h1>[4.1]<!-- -->Greedy Algorithms - Analysis</h1><p>Greedy Algorithm貪婪演算法，指的是「當一演算法 <strong>以小步驟 </strong>去發展解答，並且 <strong>每一步驟都以短淺的眼光選擇當下最好的</strong>」，基本上任何問題都很容易發展出一個貪婪演算法，因為通常是以直覺的方式想出來，但是這樣的演算法通常無法產生最佳解（not optimal）。因此，在在貪婪演算法中最困難的部份是要證明該演算法為optimal，通常我們以下面兩種方法來證明：</p><ol><li>The greedy algorithm stays ahead - 該演算法在每一步都維持最佳解</li><li>An exchange argument - 對任何candidate solution，若不是optimal的部分便換掉換成另一種組合</li></ol><h2 class="anchor anchorWithStickyNavbar_mojV" id="stays-ahead---interval-scheduling">Stays Ahead - Interval Scheduling<a class="hash-link" href="#stays-ahead---interval-scheduling" title="Direct link to heading">​</a></h2><p>Interval Scheduling 是一經典問題。</p><p><strong>Given :</strong> 一堆附有起始、結束時間的工作集合（set of jobs with start times and finish times）</p><p><strong>Goal :</strong>找到能達到最多工作且工作不重疊的子集合（find maximum cardinality subset of mutually compatible jobs）</p><p>e.g.為機檯安排工作，只有一台機器，要處理愈多工作愈好。如下表，共有i1~i10的時間段（interval）及A~G共7個工作的起始結束時間，要安排最多的工作，解答可以是{A,E,G}</p><table><thead><tr><th>A</th><th>A</th><th>A</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td>B</td><td>B</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td>C</td><td>C</td><td>C</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td>D</td><td>D</td><td>D</td><td>D</td><td>D</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>E</td><td>E</td><td>E</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td>F</td><td>F</td><td>F</td><td>F</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td>G</td><td>G</td><td>G</td><td>G</td></tr><tr><td>i1</td><td>i2</td><td>i3</td><td>i4</td><td>i5</td><td>i6</td><td>i7</td><td>i8</td><td>i9</td><td>i10</td></tr></tbody></table><h3 class="anchor anchorWithStickyNavbar_mojV" id="設計演算法">設計演算法<a class="hash-link" href="#設計演算法" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_mojV" id="greedy-rule--重複repeat直到執行完所有interval">Greedy Rule : 重複Repeat，直到執行完所有Interval<a class="hash-link" href="#greedy-rule--重複repeat直到執行完所有interval" title="Direct link to heading">​</a></h4><p>從i1開始選擇一個工作，一但有工作被接受後，就排除所有與其衝突的工作，例如選A就排除BC。接者選擇下一個interval，直到所有interval都選擇完畢。</p><p>接下來另一個重要的事情就是要決定：<strong>要選擇哪一個工作</strong>，一般我們可以想到下面四種方法</p><ol><li>找最找開始的</li><li>找有最短區間的</li><li>找與其他工作衝突最小的</li><li>找最找結束的</li></ol><p>這就是貪婪演算法的實行過程，我們幾乎可以很快想出幾種演算法，但是困難的地方就是 <strong>究竟它們可以給我們最佳解嗎？</strong>我們先試著看有沒有反例可以說明該演算法無法得出最佳解。</p><p>實心色塊代表我們所選擇的；空心則是因為選擇實心而會被放棄的。</p><ol><li><p>找最找開始的</p><p><img src="/assets/images/greedy1-84b2f4f7978f64a5336029c175dcc0fd.jpg" width="1537" height="345"></p></li><li><p>找有最短區間的</p><p><img src="/assets/images/greedy2-a32ff33e42ff5835e509786073fb679d.jpg" width="1537" height="344"></p></li><li><p>找與其他工作衝突最小的</p><p><img src="/assets/images/greedy3-4bcead668d2641cd8ee4295046948fed.jpg" width="1570" height="492"></p></li><li><p>找最找早結束的</p><p>對於這一演算法想不到可能違反最佳解的例子，於是我們先將此演算法以Pseudo Code表示，在進一步分析。</p></li></ol><h4 class="anchor anchorWithStickyNavbar_mojV" id="pseudo-code">Pseudo Code<a class="hash-link" href="#pseudo-code" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_I0IT language-pseudocode theme-code-block"><div class="codeBlockContent_wNvx pseudocode"><pre tabindex="0" class="prism-code language-pseudocode codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">Initially let R be the set of all requests, and let the set of accepted requests A be empty </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">While R is not yet empty</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Choose a request i∈R that has the smallest finishing time</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Add request i to A</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Delete all requests from R that are not compatible with request i</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">EndWhile</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Return the set A as the set of accepted requests</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><img src="/assets/images/greedy4-7026f61a97998ede5394f35c4ce87dfd.jpg" width="1043" height="793"></p><h3 class="anchor anchorWithStickyNavbar_mojV" id="分析演算法">分析演算法<a class="hash-link" href="#分析演算法" title="Direct link to heading">​</a></h3><p>首先對於我們得到的被接受的要求集合A，</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="定理1"><strong>定理1</strong><a class="hash-link" href="#定理1" title="Direct link to heading">​</a></h4><blockquote><p>A是一相容解集合</p></blockquote><p>接下來要一步步證明此演算法是optimal，我們假設此問題存在一最佳解O，那麼我們會希望求解出來的A=O，但是我們又無法保證此問題僅有一最佳解的集合，且我們的要求是要求 <strong>完成最多數量的requests</strong>，因此我們僅須證明|A|=|O|，也就是兩集合包含相同數量即可。</p><p>接下來如同標題所寫，我們以&quot;Stay ahead&quot;來證明，也就是說A至少或優於O。比較貪婪演算法建構起來的部分A是否優於O的部分，且每一步都是優於O的。</p><h5 class="anchor anchorWithStickyNavbar_mojV" id="符號定義">符號定義<a class="hash-link" href="#符號定義" title="Direct link to heading">​</a></h5><p>s(i) 為requests i 的起始時間</p><p>f(i) 為requests i 的結束時間</p><p>R 所有可被選擇的requests集合</p><p>A={i1, ...., ik } 演算法產生的集合A包含k個被接受的requests，且i照時間上升排序。</p><p>O={j1, ... , jm} 最佳解集合O包含m個被接受的requests，且j照時間上升排序。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="定理2"><strong>定理2</strong><a class="hash-link" href="#定理2" title="Direct link to heading">​</a></h4><blockquote><p>對於所有註標r ≤ k，f(ir) ≤ f(jr)</p></blockquote><p>這一定理是為了符合我們所說 <strong>集合A stays ahead O</strong>，所以f(ir)至少會小於等於 f(jr)。</p><h5 class="anchor anchorWithStickyNavbar_mojV" id="證明">證明<a class="hash-link" href="#證明" title="Direct link to heading">​</a></h5><p><img src="/assets/images/greedy5-a0aebd7b88318d1242bbaafdbc671030.jpg" width="1371" height="180"></p><p>以歸納法證明，在r=1時，此定理必然為真，因為演算法會挑出最早結束的時間（f(ir)最小的ｉ）。</p><p>現在證明r&gt;1的部分，我們歸納假設 &quot;此定理在r-1時仍為真&quot;，並試著證明在r時也成立。以上述假設我們可以說<strong>f(ir-1) ≤ f(jr-1)</strong>，見上圖，但是否會出現在f(ir) &gt; f(jr)的情形呢？不，因為如上圖所示，演算法永遠有機會選擇jr（較早結束），以滿足我們的假設。</p><p>又因為O為最佳解，代表裡面的requests必然不衝突，因此得到f(jr-1) ≤ s(jr)，而f(ir-1) ≤ f(jr-1)，所以 <strong>f(ir-1) ≤s(jr)</strong>，代表在選擇完ir-1要選擇下一個request時，我們可以選擇jr（jr在集合R當中），而該演算法會挑選最早完成的，因此可以知道f(ir) 至少小於等於 f(jr)，完成歸納步驟。</p><p>因此目前我們可以確定貪婪演算法在每一個r中，保持優於最佳解O，因為定理2所述，A當中每個選擇都至少小於等於O。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="定理3">定理3<a class="hash-link" href="#定理3" title="Direct link to heading">​</a></h4><blockquote><p>此貪婪演算法回傳一最佳解集合A</p></blockquote><h5 class="anchor anchorWithStickyNavbar_mojV" id="證明-1">證明<a class="hash-link" href="#證明-1" title="Direct link to heading">​</a></h5><p>以反證法證明，若A並非最佳解，那麼O必然有多出一個request，也就是說m&gt;k。使用定理2，當r=k時，我們有f(ik) ≤ f(jk)，而m&gt;k，代表O存在jk+1，此request在jk結束後開始（當然也必然在ik之後）。代表在我們挑選完i1, ..., ik並刪除集合R當中與之衝突的requests時，仍剩下一個request jk+1，但是此貪婪演算法的終止條件是R為空集合，產生矛盾。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="實行與執行時間">實行與執行時間<a class="hash-link" href="#實行與執行時間" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_I0IT language-pseudocode theme-code-block"><div class="codeBlockContent_wNvx pseudocode"><pre tabindex="0" class="prism-code language-pseudocode codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">1.Initially let R be the set of all requests, and let the set of accepted requests A be 2.empty </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3.While R is not yet empty</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4.  Choose a request i∈R that has the smallest finishing time</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5.  Add request i to A</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6.  Delete all requests from R that are not compatible with request i</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">7.EndWhile</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">8.Return the set A as the set of accepted requests</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>演算法時間複雜度為O(nlogn)，主要有以下步驟</p><ul><li>將集合R當中的元素依升冪排序 （排序最快為O(nlogn)）</li><li>紀錄開始時間，陣列S, S<!-- -->[i]<!-- -->=s(i) （O(n)）</li><li>while迴圈會掃描一遍集合R （O(n)）</li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="stays-ahead---interval-partition">Stays Ahead - Interval Partition<a class="hash-link" href="#stays-ahead---interval-partition" title="Direct link to heading">​</a></h2><p>也稱為Interval Coloring Problem，算是上一節 </p><p><a href="#StaysAhead-IntervalScheduling">Interval Scheduling </a></p><p>的一種，這次是要以最少的資源去完成所有工作</p><p><strong>Given :</strong> 一堆附有起始、結束時間的工作集合（set of jobs with start times and finish times）</p><p><strong>Goal :</strong>將這些request分割成數個（追求最少個數）相容的子集合，每個集合會分配到一資源。</p><p><img src="/assets/images/greedy6-134fa0d298ba6b090098688ad5606823.jpg" width="721" height="232"></p><h4 class="anchor anchorWithStickyNavbar_mojV" id="定理1-1">定理1<a class="hash-link" href="#定理1-1" title="Direct link to heading">​</a></h4><blockquote><p>至少需要和interval集合深度（depth）一樣多的資源。</p></blockquote><p>*以上圖為例，depth就是3。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="考慮兩個問題">考慮兩個問題<a class="hash-link" href="#考慮兩個問題" title="Direct link to heading">​</a></h4><ol><li>是否能發展一演算法排完所有的requests且使用最少的資源</li><li>真的都存在一schedule使用最少的資源（資源數等於其depth）</li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="設計演算法-1">設計演算法<a class="hash-link" href="#設計演算法-1" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_I0IT language-pseudocode theme-code-block"><div class="codeBlockContent_wNvx pseudocode"><pre tabindex="0" class="prism-code language-pseudocode codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">Sort the intervals by their start times, breaking ties arbitrarily</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Let I1,I2,...,Ik denote the intervals in this order</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">For j=1,2,3,...,k</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    For each interval Ii that precedes Ij in the sorted order and overlaps it</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Exclude the label of Ii from consideration for Ij</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EndFor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    If there is any label from {1,2,...,d} that has not been excluded then </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Assign a nonexcluded label to Ij</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Leave Ij unlabeled</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EndIf</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">EndFor</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="an-exchange-argument---scheduling-to-minimize-lateness">An exchange argument - Scheduling to minimize lateness<a class="hash-link" href="#an-exchange-argument---scheduling-to-minimize-lateness" title="Direct link to heading">​</a></h2><p>可以用交作業的概念來解釋。不過目標是有最少的遲交時間，通常現實生活只要遲交就是不行：（</p><p><strong>Given:</strong> a single resource is available. A set of requests {1, 2, ..., n}, ith request requires time of length ti and has deadline di </p><p><strong>Goal:</strong> schedule all requests without overlapping to minimize the maximum  lateness </p><p>Lateness: li = max{0, fi -di }</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="greedy-rule">Greedy Rule<a class="hash-link" href="#greedy-rule" title="Direct link to heading">​</a></h4><ul><li><p>找所需時間最短的</p><p>反例:做完1在做2會讓2遲交，但其實可以兩個都不。</p><table><thead><tr><th>任務</th><th>1</th><th>2</th></tr></thead><tbody><tr><td>t（完成所需天數）</td><td>1</td><td>10</td></tr><tr><td>d（距離截止日期天數）</td><td>100</td><td>10</td></tr></tbody></table></li><li><p>smallest slack（也就是d-t最小）</p><p>反例:先做2，會讓1的延遲大幅提升。</p><table><thead><tr><th>任務</th><th>1</th><th>2</th></tr></thead><tbody><tr><td>t（完成所需天數）</td><td>1</td><td>10</td></tr><tr><td>d（距離截止日期天數）</td><td>2</td><td>10</td></tr></tbody></table></li><li><p>找截止時間最近的</p><p>暫時找不到，所以要來證明，雖然乍看之下，他完全不考慮任務執行所需時間有點不合理。</p></li></ul><h4 class="anchor anchorWithStickyNavbar_mojV" id="pseudo-code-1">Pseudo Code<a class="hash-link" href="#pseudo-code-1" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_I0IT language-pseudocode theme-code-block"><div class="codeBlockContent_wNvx pseudocode"><pre tabindex="0" class="prism-code language-pseudocode codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">Interval-partitioning(n,t1,..,tn,d1,..,dn)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Setup t=0 and sort requests so that d1&lt;=...&lt;=dn</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">For j=1 to n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assign request j to time interval [t,t+tj]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sj=t,fj=t+tj</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    t=t+tj</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="定理1-2">定理1<a class="hash-link" href="#定理1-2" title="Direct link to heading">​</a></h4><blockquote><p>存在一最佳排程，其不含idle time</p></blockquote><p>*idle time指的是有時間沒有排工作。</p><p>因為先做deadline最近的，所以做完後一定有其他工作可以做。</p><p>我們求出來的解稱為A，而問題本身存在一最佳解O，目標是將O逐步改為A，但過程中確保依舊保持最佳解。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="定理2-1">定理2<a class="hash-link" href="#定理2-1" title="Direct link to heading">​</a></h4><blockquote><p>所有沒有inversion和idle time的排程都含有相同的最大延遲時間</p></blockquote><p>*inversion指的是截止日較晚的工作i被排在截止日較近的工作j之前。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="定理3-1">定理3<a class="hash-link" href="#定理3-1" title="Direct link to heading">​</a></h4><blockquote><p>存在一最佳解，沒有inversion和idle time</p></blockquote><h5 class="anchor anchorWithStickyNavbar_mojV" id="證明-2">證明<a class="hash-link" href="#證明-2" title="Direct link to heading">​</a></h5><p>從一不含idle time的最佳解開始，</p><ul><li>如果O有inversion，那麼存在一排程{i,j}，但di&gt;dj</li></ul><p>假設O至少有一個inversion，且如上所假設是工作i,j，我們將ij交換，減少inversion，且不會增加新的inversion。</p><ul><li>在交換ij後，得到少了一組inversion的O</li></ul><p>最難的部分就是要證明交換後的O仍是optimal，也就是下面這點</p><ul><li>新的排程所擁有的最大延遲不會大於原本的排程</li></ul><p>原先的排程至多可以有n取2個inversion，也就是至多n取2個交換就可以得到沒有inversion的最佳解。因此我們就是希望證明交換一對又一對的工作時，不會增加最大延遲。</p><p>用一些符號表是最佳排程O</p><p>每一個request r配安排在時間區間<!-- -->[s(r),f(r)]<!-- -->，且其延遲時間為lr&#x27;，L&#x27; = max(lr&#x27;)。</p><p>原本的工作是i,j，且di&gt;dj，用f、l表示。將ij交換，變成j,i並以f&#x27;和l&#x27;表示。</p><p>l&#x27;(i) = f&#x27;(i)-d(i)， f&#x27;(i)-d(i) 又等於f(j)-d(i)，</p><p>且dj&lt;di，所以</p><p>l&#x27;(i) =f(j)-d(i) &lt; f(j) - d(j)=l(j)</p><p>由上面等式可以知道I&#x27;(i) &lt; l(j)，也就是交換後並不會增加最大延遲時間。</p><blockquote><p>演算法產生的排程A會有最佳的最大延遲時間。</p></blockquote></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/yehs1225/yehs1225.github.io/docs/Algorithm/Algorithm[4_1].md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_foO9"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/Algorithm/Algorithm[3]"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">[3]Graphs</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/Algorithm/Algorithm[4_2]"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">[4.2]Greedy Algorithm - Shortest Path &amp; MST</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#stays-ahead---interval-scheduling" class="table-of-contents__link toc-highlight">Stays Ahead - Interval Scheduling</a><ul><li><a href="#設計演算法" class="table-of-contents__link toc-highlight">設計演算法</a></li><li><a href="#分析演算法" class="table-of-contents__link toc-highlight">分析演算法</a></li><li><a href="#實行與執行時間" class="table-of-contents__link toc-highlight">實行與執行時間</a></li></ul></li><li><a href="#stays-ahead---interval-partition" class="table-of-contents__link toc-highlight">Stays Ahead - Interval Partition</a><ul><li><a href="#設計演算法-1" class="table-of-contents__link toc-highlight">設計演算法</a></li></ul></li><li><a href="#an-exchange-argument---scheduling-to-minimize-lateness" class="table-of-contents__link toc-highlight">An exchange argument - Scheduling to minimize lateness</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Tzu Hsuan Yeh. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.563c7ca5.js"></script>
<script src="/assets/js/main.d47f52f6.js"></script>
</body>
</html>