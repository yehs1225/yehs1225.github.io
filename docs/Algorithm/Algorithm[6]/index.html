<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-Algorithm/Algorithm[6]">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.22">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Yeh&#39;s blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Yeh&#39;s blog Atom Feed"><title data-rh="true">[6]Dynamic Programming | Yeh&#x27;s blog</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://your-docusaurus-test-site.com/docs/Algorithm/Algorithm[6]"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="[6]Dynamic Programming | Yeh&#x27;s blog"><meta data-rh="true" name="description" content="我們前面學過greedy algorithm、divide and conquer的技巧。然而有許多問題無法是無法發展出greedy algorithm的，而divide and conquer在前面主要探討將時間複雜度限縮在polynomial time的困難度。現在要來說明Dynamic Programming，基本的想法是"><meta data-rh="true" property="og:description" content="我們前面學過greedy algorithm、divide and conquer的技巧。然而有許多問題無法是無法發展出greedy algorithm的，而divide and conquer在前面主要探討將時間複雜度限縮在polynomial time的困難度。現在要來說明Dynamic Programming，基本的想法是"><link data-rh="true" rel="icon" href="/img/favicon.png"><link data-rh="true" rel="canonical" href="https://your-docusaurus-test-site.com/docs/Algorithm/Algorithm[6]"><link data-rh="true" rel="alternate" href="https://your-docusaurus-test-site.com/docs/Algorithm/Algorithm[6]" hreflang="en"><link data-rh="true" rel="alternate" href="https://your-docusaurus-test-site.com/docs/Algorithm/Algorithm[6]" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.63610d8e.css">
<link rel="preload" href="/assets/js/runtime~main.eb4a2e2b.js" as="script">
<link rel="preload" href="/assets/js/main.a9564f8c.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/favicon.png" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/favicon.png" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">My Site</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/intro">Notes</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/yehs1225" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">Notes Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/docs/Algorithm/Algorithm[1]">Algorithm</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[1]">[1]Intro : Some Representative problems</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[2]">[2] Basic of Algorithm Analysis</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[3]">[3]Graphs</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[4_1]">[4.1]Greedy Algorithms - Analysis</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[4_2]">[4.2]Greedy Algorithm - Shortest Path &amp; MST</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[5]">[5]Divide and Conquer</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/Algorithm/Algorithm[6]">[6]Dynamic Programming</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[7]">[7] Network Flow</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[8]">[8] NP and Computational Intractability</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[9]">[9]Approximation Algorithm</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/BasicKnowlege/CSS-RWD切版練習">BasicKnowlege</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/DataStructures/Graph">DataStructures</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/Django/[DJ]Deploy">Django</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/Docker/Docker1基本介紹">Docker</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/JavaScript/JavaScript-this">JavaScript</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/Python/Python_Class">Python</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/Reactjs/React_ES6">Reactjs</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/Tools/Command-Line-and-Vim">Tools</a></div></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Algorithm</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">[6]Dynamic Programming</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>[6]<!-- -->Dynamic Programming</h1><p>我們前面學過greedy algorithm、divide and conquer的技巧。然而有許多問題無法是無法發展出greedy algorithm的，而divide and conquer在前面主要探討將時間複雜度限縮在polynomial time的困難度。現在要來說明Dynamic Programming，基本的想法是</p><ul><li>謹慎地將問題解構成一系列的子問題</li><li>經由不停建構子問題的正確答案，最後成為整個問題的解</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="weighted-interval-scheduling">Weighted Interval Scheduling<a class="hash-link" href="#weighted-interval-scheduling" title="Direct link to heading">​</a></h2><p>第一步先想到之前學的greedy algorithm有沒有辦法找到解答，NO。在這裡我們要用recursive的方式求出演算法。</p><ul><li>有n個request, 標示為1, ... , n。</li><li>每個request i 有起始時間si, 結束時間fi, 價值（weight）vi。</li><li>兩個request是相容的，若它們沒有重疊</li><li>假設request是以結束時間依上升排列：f1 ≤ f2 ≤ ... ≤ fn，我們會說request i 在j之前，若且唯若i&lt;j。</li><li>P(j)，表示在j前有多少個request不和它衝突。（如下圖說明）</li></ul><p>目標：挑選出request 各自相容的集合S ⊆ {1, . . . , n},最大化 Σ i∈S vi。</p><p><img loading="lazy" src="/assets/images/dynamic1-1b659023b98aea79d2c517bf6dee8b3f.jpg" width="1150" height="565" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="design-algorithm">Design Algorithm<a class="hash-link" href="#design-algorithm" title="Direct link to heading">​</a></h3><p>假設此問題有一最佳解O，儘管目前我們不知道確切是甚麼。</p><ul><li>Oj 是最佳解for intervals 1,2,...,j</li><li>OPT(j)是最佳解for intervals 1,2,...,j的<strong>值</strong></li></ul><p><strong>例子說明</strong></p><p>OPT6有兩種可能</p><ol><li>V6 + OPT(3)</li><li>OPT(5)</li></ol><p>所以OPT(6) = max{V6 + OPT(3), OPT(5)}</p><p>general form : OPT(j) = max{{Vj + OPT(P(j))}, OPT(j-1)}</p><p><img loading="lazy" src="/assets/images/dynamic2-f21a97c3f14ff7cb1cae64ea80a8fef4.jpg" width="1332" height="333" class="img_ev3q"></p><div class="language-pseudocode codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-pseudocode codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//Preprocessing</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//Sort intervals by finish times：f1≤f2≤...≤fn</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//Compute p(1),p(2),...,p(n)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Compute-Opt(j)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">If (j=0) then </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return  max{{Vj + Compute-OPT(P(j))}, Compute-OPT(j-1)}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="memoizing-the-recursion--top-down">Memoizing the Recursion : Top-Down<a class="hash-link" href="#memoizing-the-recursion--top-down" title="Direct link to heading">​</a></h3><p>到目前為止，我們的演算法仍是exponential time，因為Compute-OPT只是解決了n+1個子問題（Compute-Opt(0), ...., Compute-Opt(n)）。解決辦法是將計算過的值放在全域變數，使其可以在之後recusive call時被取用，這樣的技巧稱為memoization。我們另外設一陣列M<!-- -->[0...n]<!-- -->來儲存。</p><div class="language-pseudocode codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-pseudocode codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">M-Compute-Opt(j)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">If j=0 then</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Return 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Else if M[j] is not empty then</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Return M[j]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Define M[j] = max(Vj + M-Compute-Opt, M-Compute-Opt(j-1))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Return M[j]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Endif</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>M-Compute-Opt(n)的執行時間為O(n)。（假設輸入的Interval已照finish time被排序）</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="iteration--bottom-up">Iteration : Bottom-up<a class="hash-link" href="#iteration--bottom-up" title="Direct link to heading">​</a></h3><p>當然也可以用迴圈的方式處理M陣列。</p><div class="language-pseudocode codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-pseudocode codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Iterative-Compute-Opt</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">M[0] = 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">For j = 1,2,...,n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    M[j] = max(Vj + M[p(j)], M[j-1])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Endfor</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="difference-between-memoization-and-iteration">Difference between Memoization and Iteration<a class="hash-link" href="#difference-between-memoization-and-iteration" title="Direct link to heading">​</a></h4><ul><li>Memoization : Compute only when we need</li><li>Iteration : Compute every small piece. Construct from the smallest subproblem to the largest one.</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="computing-a-soloution">Computing a Soloution<a class="hash-link" href="#computing-a-soloution" title="Direct link to heading">​</a></h3><p>前面的演算法只算出最佳解的值，現在要來真正求出解集合。最直覺想到的辦法可能是用一新的陣列S來儲存最佳解集合，但這樣會多花費時間到O(n)，總時間會變成O(n^2)。</p><p>從上面尋找OPT的general form的程序時，可以發現interval i 會被納入最佳解，若且唯若Vj + OPT(P(j))  ≥  OPT(j-1)。因此我們只要加上條件判斷，就可以蒐集到我們要的。</p><div class="language-pseudocode codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-pseudocode codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Find-Solution(j)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">If j = 0 then</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Output nothing</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    If vj + M[p(j)]≥ M[j − 1] then</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Output j together with the result of Find-Solution(p(j))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Output the result of Find-Solution(j − 1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Endif</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>當我們有一子問題的最佳解陣列M，找到解法的時間複雜度為O(n)。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="key-for-dynamic-programming">Key for Dynamic Programming<a class="hash-link" href="#key-for-dynamic-programming" title="Direct link to heading">​</a></h2><p>一般用來<strong>最佳化</strong>問題，很適合拿來處理linearly ordered的問題（前面例子就是）。適用的問題必須符合以下特性：</p><ol><li>只有 <strong>polynomial</strong>個數的子問題</li><li>問題的解答要可以經由子問題的解答簡單地計算而來</li><li>子問題存在自然的順序由小到大，達到easy-to-compute-recurrence</li></ol><p>組成Dynamic Programming的兩大要素：</p><ol><li>Optimal substructure</li><li>Overlapping subproblem</li></ol><p>一般作業流程：</p><ol><li>將答案變成一種reccurence的關係，或是說recursive的演算法（從divide-and-conquer開始）</li><li>證明在你的演算法流程中每個環節都可以被限定在polynomial</li><li>釐清遞迴呼叫中需要計算的物件順序，使得每次呼叫都可以取得需要的物件</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="segmented-least-squares">Segmented Least Squares<a class="hash-link" href="#segmented-least-squares" title="Direct link to heading">​</a></h2><p>在上一個問題Weighted Interval Scheduling當中，我們的選擇只有要或不要（選取某一interval），現在要探討的問題是統計中很常用到的 <strong>尋找多條最適線來符合二維座標中的數個點</strong>。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="一條最適直線">一條最適直線<a class="hash-link" href="#一條最適直線" title="Direct link to heading">​</a></h4><p>找到a, b來決定最適直線L，並且要求最小化Error。</p><p><img loading="lazy" src="/assets/images/dynamic3-0266c263e2bd84bf69749faa3de053d7.jpg" width="1232" height="524" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="多條最適直線">多條最適直線<a class="hash-link" href="#多條最適直線" title="Direct link to heading">​</a></h4><p>將所有點切成數個部分（segments），分別都有一條最適直線。</p><p><img loading="lazy" src="/assets/images/dynamic4-422337daf06ba0c67abad1d2e0b72d56.jpg" width="1573" height="409" class="img_ev3q"></p><p>以下兩種情況是不允許的</p><ol><li>有點沒被分到任意segments中</li><li>segment中的連續兩點參雜了其他segment的點</li></ol><p><img loading="lazy" src="/assets/images/dynamic5-3b9901f502326d83eef3262d2c68c969.jpg" width="1573" height="409" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="design-algorithm-1">Design Algorithm<a class="hash-link" href="#design-algorithm-1" title="Direct link to heading">​</a></h3><p>給予n個點於二維座標P = {(x1,y1), ... , (xn, yn)}，要決定K值，指的是分成k個segments。</p><ul><li>將p分為k個segments：{P1,...,Pk}</li><li>對Pj來說，有一條最適直線L = ajx + bj</li><li>最小化：加總j=1~k的Error(Lj, Pj) + Ck （其中Ck稱為penalty term，用來控制不可以分成太多segments）</li></ul><p>此問題有一最佳解O</p><ul><li>e(i,j) 是最適直線的error值。此最適值線適於包含{pi,...,pj}的segment。</li><li>OPT(i)是{p1,...,pi}中每條最適直線的加總error值（optimal）</li></ul><p>目標是計算OPT(n)</p><p>general form : OPT(n) = e(i,n) + OPT(i-1) + C  </p><p>（加上C是因為多加了一條線的懲罰值）</p><p>若最後一個segment是{pi, pi+1, ... , pj}則</p><p>OPT(j) = e(i,j) + C + OPT(j-1)</p><p>而我們會需要從1~j都執行這樣的步驟，所以最終的OPT(j)應修改成如下：</p><p><img loading="lazy" src="data:image/jpeg;base64,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" width="496" height="67" class="img_ev3q"></p><div class="language-pseudocode codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-pseudocode codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Segmented-Least-Squares(n)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Array M[0,...,n]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Set M[0] = 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">For all pairs i≤j</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Compute the least squares error e(i,j) for the segment pi,...,pj</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">EndFor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">For j=1,2,..,n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    M[j] = min{e(i,j) + C + M[i-1]} （其中1≤i≤j）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Endfor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">return M[n]</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>時間複雜度為O(n^3)：花n^2時間計算e(i,j)，每次計算最多n。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="shortest-path-with-negative-edges">Shortest Path with Negative Edges<a class="hash-link" href="#shortest-path-with-negative-edges" title="Direct link to heading">​</a></h2><p>之前探討過的Dijkstra Algorithm只能用在非負的邊上，下面我們嘗試做一些修正，以及探討他仍舊存在的問題。</p><ul><li>Observation：一開始成本較低的最後可能會劣於一開始成本較高，但後來因為負值加入而下降的成本。</li><li>Reweighting：將每個值都加上一數，使得沒有一條邊是負數。但會造成某些路徑（經過比較多邊的路徑）被過度加上成本值。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="bellman-ford-algorithm">Bellman-Ford Algorithm<a class="hash-link" href="#bellman-ford-algorithm" title="Direct link to heading">​</a></h3><p>試圖用Dynamic Programming在含有負邊但沒有負迴圈的圖找到最短路徑。想法是：子問題i可以用前i個點找到最短路徑。</p><p><strong>定理1</strong></p><blockquote><p>若G沒有負迴圈，那麼會存在一條最短路徑從s-t是simple的（沒有重複的點），也代表僅含有n-1條邊。</p></blockquote><p><strong>證明</strong></p><p>用反證法。假設有條路徑P為s-v-t且會重複在點v，那麼因為成本值都不回負值，所以一定可以移除掉重複v的部分，形成一條更短的路徑Q。</p><p><strong>符號定義</strong></p><p>OPT(i,v)：以v做起點到達一固定終點t，且最多只用i條邊的成本值。根據定理1，OPT(n-1,s) = s-t最短路徑長。</p><p>現在要用更小的子問題來表達OPT(i,v)。path P如下圖示，考慮下面兩種可能情形</p><p><img loading="lazy" src="/assets/images/dynamic7-d7683bfc5a9668c12192ef10c2e4d83c.jpg" width="982" height="220" class="img_ev3q"></p><ol><li><p>P至多使用i-1條邊，那麼OPT(i,v) = OPT(i-1,v)</p><p>（針對第i條邊可以選擇不去使用他）</p></li><li><p>P確實使用i條邊，且第一條邊是(v,w)，那麼OPT(i,v) = Cvw + OPT(i-1,w)</p><p>（選擇使用第i條邊，相當於 選了第一條(v,w)後，剩下的i-1條邊仍組成最短路徑）</p></li></ol><p><strong>定理2</strong></p><blockquote><p>If i &gt; 0 then OPT(i, v) = min(OPT(i − 1, v), min w∈V (OPT(i − 1, w) + Cvw))</p></blockquote><div class="language-pseudocode codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-pseudocode codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Bellman-Ford(G,s,t)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">n = number of nodes in G</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Array M[0...n-1, V]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Define M[0,t] = 0 and M[0,v] = ∞ for all other v ∈ V</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">For i = 1,...,n-1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    For v ∈ V in any order</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        M[i,v] = min(M[i−1], v), min w∈V (M[i− 1,w]) + Cvw))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EndFor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">EndFor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Return M[n-1,s]</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>初始化會長的像下圖。例如第一列第二行為OPT(1,t)，亦即「從t到t至多走一步需要cost=0」。</p><p><img loading="lazy" src="/assets/images/dynamic8-8cb152b54d49de357d0883f45a2d011e.jpg" width="806" height="493" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="negative-cycle">Negative Cycle<a class="hash-link" href="#negative-cycle" title="Direct link to heading">​</a></h4><p>此演算法不適用於含有負值的cycle，因為會造成不停地經過負迴圈來減少cost的情形。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="application--currency-conversion">Application : Currency Conversion<a class="hash-link" href="#application--currency-conversion" title="Direct link to heading">​</a></h2><p>給予下圖的n種貨幣及之間的匯率關係，尋找是否有套利的空間。觀察粉紅色的三個點，從$ -&gt; F -&gt; E計算個匯率關係乘積=1.0084，會形成套利。</p><p>圖中的node是貨幣；edge是匯率，而我們先前的shortest path是將成本加總，但這裡是需要相乘的關係。</p><p><img loading="lazy" src="/assets/images/dynamic9-bff29f14a3c344e05fe045142ed114a7.png" width="820" height="278" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="convertion">Convertion<a class="hash-link" href="#convertion" title="Direct link to heading">​</a></h4><p>要將<strong>相乘</strong>轉變為<strong>相加</strong>的關係，可以想到<strong>log</strong></p><p>原先為1.3941 <em> 0.6677 </em> 1.0752 &gt; 1，兩邊取-log</p><p>log(1.3941 <em> 0.6677 </em> 1.0752 ) &lt; log(1)</p><p>log(1.3941) + log(0.6677) + log(1.0752) &lt; 0</p><p>所以我們可以將邊上的匯率取-log，然後用原本路徑成本相加的方式，若發現一路徑成本小於0就代表有套利空間。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="negative-cycle-detection">Negative Cycle Detection<a class="hash-link" href="#negative-cycle-detection" title="Direct link to heading">​</a></h2><p>Bellman-Ford Algorithm並不適用於negative cycle，當G含有negative cycle時，我們很自然地會想到兩個問題：</p><ol><li>要如何得知G是否有negative cycle</li><li>要如何在有negative cycle的G中找到它</li></ol><p>透過發展找到negative cycle的演算法可以幫助我們改善Bellman-Ford Algorithm，因此下面討論如何發現含有negative cycle。</p><p>Bellman-Ford：OPT(i,v) = OPT(n-1,v) for all v and i≥n，表示我們只需要至多n-1條就會是最小成本的路徑了，所以如果 </p><blockquote><p>對於某些點v來說，OPT(n,v) &lt; OPT(n-1,v)，則此最短路徑含有negative cycle。</p></blockquote><p><strong>證明</strong></p><p>以反證法證明。</p><ul><li>因為OPT(n,v) &lt; OPT(n-1,v)，P恰好有n條邊。</li><li>任何至多用n-1條邊的路徑，成本必定大於P。</li><li>P一定有cycle。</li><li>若C不是negative cycle，刪除C產生的路徑（#edges &lt; n）成本不會更大。</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="overview-4-algorithmic-paradigms">Overview 4 Algorithmic Paradigms<a class="hash-link" href="#overview-4-algorithmic-paradigms" title="Direct link to heading">​</a></h2><ol><li><h4 class="anchor anchorWithStickyNavbar_LWe7" id="brute-force">Brute-force<a class="hash-link" href="#brute-force" title="Direct link to heading">​</a></h4><p>要檢查所有可能的答案，其實多半是作為和其他方法比較的基準。</p></li><li><h4 class="anchor anchorWithStickyNavbar_LWe7" id="greedy">Greedy<a class="hash-link" href="#greedy" title="Direct link to heading">​</a></h4><p>目光短淺地在每一階段都挑選當下最好的解。</p></li><li><h4 class="anchor anchorWithStickyNavbar_LWe7" id="divide-and-coquer">Divide-and-Coquer<a class="hash-link" href="#divide-and-coquer" title="Direct link to heading">​</a></h4><p>將問題拆成兩部分，獨立解決兩個子問題，在將子問題合併得到完整的解答。</p></li><li><h4 class="anchor anchorWithStickyNavbar_LWe7" id="dynamic-programming">Dynamic Programming<a class="hash-link" href="#dynamic-programming" title="Direct link to heading">​</a></h4><p>將問題拆成一序列有關聯的子問題，並且將子問題一步步解決，直到完成完整的問題。</p></li></ol></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/yehs1225/yehs1225.github.io/docs/Algorithm/Algorithm[6].md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/Algorithm/Algorithm[5]"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">[5]Divide and Conquer</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/Algorithm/Algorithm[7]"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">[7] Network Flow</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#weighted-interval-scheduling" class="table-of-contents__link toc-highlight">Weighted Interval Scheduling</a><ul><li><a href="#design-algorithm" class="table-of-contents__link toc-highlight">Design Algorithm</a></li><li><a href="#memoizing-the-recursion--top-down" class="table-of-contents__link toc-highlight">Memoizing the Recursion : Top-Down</a></li><li><a href="#iteration--bottom-up" class="table-of-contents__link toc-highlight">Iteration : Bottom-up</a></li><li><a href="#computing-a-soloution" class="table-of-contents__link toc-highlight">Computing a Soloution</a></li></ul></li><li><a href="#key-for-dynamic-programming" class="table-of-contents__link toc-highlight">Key for Dynamic Programming</a></li><li><a href="#segmented-least-squares" class="table-of-contents__link toc-highlight">Segmented Least Squares</a><ul><li><a href="#design-algorithm-1" class="table-of-contents__link toc-highlight">Design Algorithm</a></li></ul></li><li><a href="#shortest-path-with-negative-edges" class="table-of-contents__link toc-highlight">Shortest Path with Negative Edges</a><ul><li><a href="#bellman-ford-algorithm" class="table-of-contents__link toc-highlight">Bellman-Ford Algorithm</a></li></ul></li><li><a href="#application--currency-conversion" class="table-of-contents__link toc-highlight">Application : Currency Conversion</a></li><li><a href="#negative-cycle-detection" class="table-of-contents__link toc-highlight">Negative Cycle Detection</a></li><li><a href="#overview-4-algorithmic-paradigms" class="table-of-contents__link toc-highlight">Overview 4 Algorithmic Paradigms</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Tzu Hsuan Yeh. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.eb4a2e2b.js"></script>
<script src="/assets/js/main.a9564f8c.js"></script>
</body>
</html>