<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Yeh&#39;s blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Yeh&#39;s blog Atom Feed"><title data-react-helmet="true">[4.2]Greedy Algorithm - Shortest Path &amp; MST | Yeh&#x27;s blog</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://your-docusaurus-test-site.com/docs/Algorithm/Algorithm[4_2]"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="[4.2]Greedy Algorithm - Shortest Path &amp; MST | Yeh&#x27;s blog"><meta data-react-helmet="true" name="description" content="在[4-1]Greedy Algorithm - Analysis之後，我們要來看經典的應用Shortest Path 和 Minimum Spanning Tree。"><meta data-react-helmet="true" property="og:description" content="在[4-1]Greedy Algorithm - Analysis之後，我們要來看經典的應用Shortest Path 和 Minimum Spanning Tree。"><link data-react-helmet="true" rel="icon" href="/img/favicon.png"><link data-react-helmet="true" rel="canonical" href="https://your-docusaurus-test-site.com/docs/Algorithm/Algorithm[4_2]"><link data-react-helmet="true" rel="alternate" href="https://your-docusaurus-test-site.com/docs/Algorithm/Algorithm[4_2]" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://your-docusaurus-test-site.com/docs/Algorithm/Algorithm[4_2]" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.f2b17ad4.css">
<link rel="preload" href="/assets/js/runtime~main.53e15555.js" as="script">
<link rel="preload" href="/assets/js/main.e50ce15c.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/favicon.png" alt="My Site Logo" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/favicon.png" alt="My Site Logo" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">My Site</b></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/intro">Notes</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/yehs1225" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">🌜</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">🌞</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_P2Lg"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_rKC_"><div class="sidebar_CW9Y"><nav class="menu thin-scrollbar menu_SkdO"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">Notes Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active hasHref_VCh3" aria-current="page" href="/docs/Algorithm/Algorithm[1]">Algorithm</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[1]">[1]Intro : Some Representative problems</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[2]">[2] Basic of Algorithm Analysis</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[3]">[3]Graphs</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[4_1]">[4.1]Greedy Algorithms - Analysis</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/Algorithm/Algorithm[4_2]">[4.2]Greedy Algorithm - Shortest Path &amp; MST</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[5]">[5]Divide and Conquer</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[6]">[6]Dynamic Programming</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[7]">[7] Network Flow</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[8]">[8] NP and Computational Intractability</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/Algorithm[9]">[9]Approximation Algorithm</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/BasicKnowlege/CSS-RWD切版練習">BasicKnowlege</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/DataStructures/Graph">DataStructures</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/Django/[DJ]Deploy">Django</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/Docker/Docker1基本介紹">Docker</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/JavaScript/JavaScript-this">JavaScript</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/Python/Python_Class">Python</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/Reactjs/React_ES6">Reactjs</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/Tools/Command-Line-and-Vim">Tools</a></div></li></ul></nav></div></aside><main class="docMainContainer_TCnq"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="docItemContainer_vinB"><article><div class="tocCollapsible_jdIR theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_Fzxq">On this page</button></div><div class="theme-doc-markdown markdown"><h1>[4.2]<!-- -->Greedy Algorithm - Shortest Path &amp; MST</h1><p>在<!-- -->[4-1]<!-- -->Greedy Algorithm - Analysis之後，我們要來看經典的應用Shortest Path 和 Minimum Spanning Tree。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="shortest-path">Shortest Path<a class="hash-link" href="#shortest-path" title="Direct link to heading">​</a></h2><p>要找到任意單一點s到其他所有點的最短路徑。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="設計演算法">設計演算法<a class="hash-link" href="#設計演算法" title="Direct link to heading">​</a></h3><p>維持一集合S儲存&quot;我們已經決定可從s到達的最短路徑的點&quot;，稱這部分為圖G中&quot;explored&quot;的部分。最初S={s}且d(s)=0。接者我們對V-S當中每一點去找可由S中的點所連接起來的最短路徑。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="dijkstras-algorithm">Dijkstra&#x27;s Algorithm<a class="hash-link" href="#dijkstras-algorithm" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_I0IT language-pseudocode theme-code-block"><div class="codeBlockContent_wNvx pseudocode"><pre tabindex="0" class="prism-code language-pseudocode codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">Dijkstra&#x27;s Algorithm （G,l）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Let S be the set of explored nodes</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    For each u∈S, we store a distance d(u)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Initially S={s} and d(s)=0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">While S ≠ V</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Select a node v ∉ S with at least one edge from S for which d(v)′=MINe=(u,v):u∈s d(u)+le is as small as possible</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Add v to S and define d(v)=d′(v)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">EndWhile</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="分析演算法">分析演算法<a class="hash-link" href="#分析演算法" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_mojV" id="定理1">定理1<a class="hash-link" href="#定理1" title="Direct link to heading">​</a></h4><blockquote><p>考慮集合S在演算法執行中的任一階段。對於每個S中的元素u，path Pu是最短的s-u路徑。</p></blockquote><h5 class="anchor anchorWithStickyNavbar_mojV" id="證明"><strong>證明</strong><a class="hash-link" href="#證明" title="Direct link to heading">​</a></h5><p>以歸納法，當|S|=1時肯定為真。假設當|S|=k時的情況，K&gt;=1也為真。現在將|S|變為k+1，藉由加入點v，且(u,v)是s-v路徑Pv的最後一邊。</p><p>根據歸納法的假設，Pu是s-v的最短路徑，其中u屬於S。現在考慮另外一條s-v路徑P，我們希望可以證明其至少跟我們的路徑Pv一樣長。</p><p>為了到達v，P路徑一定會在某一地方離開集合S，令y為離開S後的第一個點，而x是y前面的一點且屬於S。P不可能比Pv還短，因為在離開S時，P就已經至少和Pv一樣長 : 在這第k+1迴圈中，Dijkstra 演算法肯定有考慮將y加入S（透過x），但其拒絕了這個選擇而加入了v，代表路徑P(s-x-y)一定大於路徑Pv(s-u-v)</p><h5 class="anchor anchorWithStickyNavbar_mojV" id="另一證明">另一證明<a class="hash-link" href="#另一證明" title="Direct link to heading">​</a></h5><p>P&#x27;是s-x的子路徑，因為x屬於S，所以根據假設Px是到x的最短路徑（路徑長為d(x)），得到 l(p&#x27;) &gt; l(px) =d(x)，所以經由P至y的路徑長為 :  l(p&#x27;) + l(x,y) &gt; d(x)+l(x,y) &gt;= d&#x27;(y)，且完整路徑P至少和這一路徑一樣長。最後，因為該演算法在這一回合是挑選v，代表d&#x27;(y) &gt;= d&#x27;(v) = l(Pv)。綜合上述，可得l(P) &gt;= l(p&#x27;)+l(x,y) &gt;= l(Pv)</p><p><img src="/assets/images/greedy7-0d8a297706682021c1ebc63cfb59ea5a.jpg" width="461" height="305"></p><h4 class="anchor anchorWithStickyNavbar_mojV" id="兩個觀察">兩個觀察<a class="hash-link" href="#兩個觀察" title="Direct link to heading">​</a></h4><ol><li><p>當有邊上的路徑長度為負值時，該演算法無法找到最短路徑</p></li><li><p>該演算法其實比上面敘述的更簡單，可以說是 <strong>持續地</strong> 執行BFS</p><p>像是水在水管中依序流到游進到遠的節點</p></li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="實行與時間複雜度">實行與時間複雜度<a class="hash-link" href="#實行與時間複雜度" title="Direct link to heading">​</a></h3><p>對於有n個點的圖來說，while loop會執行n-1次，每一次都會加入一點v到S，如何選擇v是相對需要投入心力的部分。從演算法直接來看的話，我們每次要加入點v（v不屬於S）會需要找從S到v的所有邊長，若圖形G有m條邊，那麼這步驟就需要O(m)，整個執行完就是O(mn)。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="更好的資料結構">更好的資料結構<a class="hash-link" href="#更好的資料結構" title="Direct link to heading">​</a></h4><p>上面步驟可能會讓執行時間很長，我們可以建立Min Heap來免去每次需要再掃描每條邊的動作，因此，時間複雜度會變成 <strong>O(m)+取出最小值並回復成heap的時間</strong> = O(mlogn)</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="mst">MST<a class="hash-link" href="#mst" title="Direct link to heading">​</a></h2><p>問題 : 一地點集合V = {v1,v2,...vn}要讓集合內每一點相通。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="定理416">定理4.16<a class="hash-link" href="#定理416" title="Direct link to heading">​</a></h4><blockquote><p>T是我們找到的最小成本的解，那麼（V , T）必定為一棵樹。</p></blockquote><h5 class="anchor anchorWithStickyNavbar_mojV" id="證明-1">證明<a class="hash-link" href="#證明-1" title="Direct link to heading">​</a></h5><p>根據定義 （V , T）一定相連connected，我們要證明他也必定不含cycle。</p><p>假設含有一cycle C，而e是C當中的一個邊。我們宣稱(V , T-{e})仍舊connected，因為之前通過e的路徑可以&quot;繞遠路&quot;以C的另一條邊到達目的地。那麼也就是說(V , T-{e})也是一個合理的解，而且因為少了e，成本又更小了，和假設矛盾（T是最小成本的解）</p><p>若我們允許一些邊的cost=0的話，也就是說我們只限定Ce是非負的，那麼這組求出來有最小成本的解可能包含許多額外的邊－這些cost=0的邊可以被刪除。僅管有這樣的情形，我們依舊總是可以找到有最小成本的解是一棵樹。</p><p>若（V , T）是一棵樹，我們稱這個子集合T⊆E是G的spanning tree，而根據上面定理4.16又可知道我們找到的是圖中最小成本的樹，因此又可稱為Minimum Spanning Tree。除非G是非常簡單（simple）的樹，否則通常會有非常多不同的解集合。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="設計演算法-1">設計演算法<a class="hash-link" href="#設計演算法-1" title="Direct link to heading">​</a></h3><p>下面介紹三種貪婪演算法</p><ol><li><p>Kruskal&#x27;s Algorithm</p><p>從最小成本的邊開始，依序加入成本再大一些的邊，再加入時考慮加入邊e時會不會造成迴圈，若會的話則捨棄e，再找下一個邊。</p></li><li><p>Prim&#x27;s Algorithm</p><p>有點像前面用Dijkstra&#x27;s Algorithm找最短路徑。我們從任一點s開始，貪婪地希望從s長出一棵樹。在每一步，我們加入從現有的樹當中，能夠以最小成本所連接到的點。</p><p>更具體地說，我們維持一集合S⊆V來存放目前為所建立的spanning tree。最初，S={s}，在每一迴圈，加入一點v到S中，其中v擁有最小的&quot;附加成本（attachment cost）&quot;MINe=(u,v):u∈S Ce,，也將邊e加入spanning tree。</p></li><li><p>Reverse-Delete Algorithm</p><p>像是使用&quot;倒轉過來的（backward）或是說&quot;Kruskal&#x27;s Algorithm。初始狀態是一完整的G=（V , E），並開始以大到小的方式選取邊去做刪除的動作。</p></li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="分析演算法---性質">分析演算法 - 性質<a class="hash-link" href="#分析演算法---性質" title="Direct link to heading">​</a></h3><p>上面的演算法都需要<strong>重複地進行&quot;插入&quot;及&quot;刪除&quot;</strong>的動作，所以要分析他們的話，可以從知道 <strong>甚麼狀況下進行這些動作是安全的</strong>。我們先採用簡化的方式，假設 : 所有邊的成本都是獨一無二的，之後再討論如何將這個假設拿掉。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="when-is-it-safe-to-include-an-edge-in-the-mst">When is it safe to include an Edge in the MST？<a class="hash-link" href="#when-is-it-safe-to-include-an-edge-in-the-mst" title="Direct link to heading">​</a></h4><h4 class="anchor anchorWithStickyNavbar_mojV" id="定理417-cut-property">定理4.17 Cut property<a class="hash-link" href="#定理417-cut-property" title="Direct link to heading">​</a></h4><blockquote><p>假設所有邊的成本都是獨一無二的。令S為是點的子集合，且S非空集合也不包含整個點集合V，令邊e=（v,w）的兩端點連接S及V-S且是最小成本的邊。那麼每一個MST包含邊e。</p></blockquote><h5 class="anchor anchorWithStickyNavbar_mojV" id="證明-2">證明<a class="hash-link" href="#證明-2" title="Direct link to heading">​</a></h5><p>令T為一不包含e的ST（spanning tree），我們要證明T並非擁有最小可能的成本。以exchange argument來執行 : 我們會在T找到一邊e&#x27;的成本大於e，且有辦法在其他ST中將e&#x27;換成e，因此這樣就可以如我們所願使得ST總成本就會小於T。</p><p>重新回憶一下，e的兩端是點v及w，T是一棵ST，所以T當中必定存在一路徑P可從v到w。從v開始，遵循path，P存在一點w&#x27;屬於V-S。令v&#x27;屬於S是路徑P上w&#x27;的前一點，e&#x27; = （v&#x27; , w&#x27;），可得e&#x27;是T中的一條邊且一端在S一端在V-S。接者用e替換掉e&#x27;，得到T&#x27; = T - {e&#x27;} + {e}，再證明T&#x27;仍是一棵MST：</p><ul><li><p>（V,T&#x27;）肯定相連connected</p><p>（V,T）是相連的，任何（V,T）中使用e&#x27;的路徑在（V,T&#x27;）可以被重新導向使用v&#x27; , v , (v,w) , w , w&#x27;</p></li><li><p>（V,T&#x27;）沒有cycle</p><p>在（V,T&#x27;+{e&#x27;}）中唯一的cycle是e和path P</p></li></ul><p>e&#x27;一端點在S,一端點在V-S，而e也是，且e成本較低。所以最後可知T&#x27;的總成本小於T。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="when-can-we-guarantee-an-edge-is-not-in-the-mst">When can we guarantee an Edge is not in the MST？<a class="hash-link" href="#when-can-we-guarantee-an-edge-is-not-in-the-mst" title="Direct link to heading">​</a></h4><h4 class="anchor anchorWithStickyNavbar_mojV" id="定理420-cycle-property">定理4.20 Cycle property<a class="hash-link" href="#定理420-cycle-property" title="Direct link to heading">​</a></h4><blockquote><p>假設所有邊的成本都是獨一無二的。C是G當中的一cycle，e是C中成本最高的邊。那麼e不屬於MST。</p></blockquote><h5 class="anchor anchorWithStickyNavbar_mojV" id="證明-3">證明<a class="hash-link" href="#證明-3" title="Direct link to heading">​</a></h5><p>令T為一包含e的ST（spanning tree），我們要證明T並非擁有最小可能的成本。以exchange argument來執行 : 用成本更低的邊來換掉e。</p><p>把T中的e刪除，使得其變成兩個components : S含有點v, V-S含有點w。所以我們想用來替換e的邊會連接兩個component，使其重新變回一棵樹。根據定義，C中除了e之外的另一條邊也有一條路徑P可從v到w，所以用存在一條邊e&#x27;可連接S和V-S，T&#x27; = T - {e} + {e&#x27;}，（V,T&#x27;）是相連且沒有cycle的，另外在成本方面e&gt;e&#x27;，所以T&#x27;&lt;T。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="sum-up">Sum up<a class="hash-link" href="#sum-up" title="Direct link to heading">​</a></h4><p>事實上，任何產生spanning tree的演算法，只要是以 <strong>重複加入邊</strong> （在cut property確保正確性之下）以及　<strong>重複刪除邊</strong>（在cycle property確保正確性之下）這兩種特性產生的，都會是MST。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="分析演算法---正確性">分析演算法 - 正確性<a class="hash-link" href="#分析演算法---正確性" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_mojV" id="the-optimality-of-kruskals-algorithms">The Optimality of Kruskal’s Algorithms<a class="hash-link" href="#the-optimality-of-kruskals-algorithms" title="Direct link to heading">​</a></h4><p>重點是 : 這兩個演算法只會在合理的時候加入新的邊（cut property）</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="定理418">定理4.18<a class="hash-link" href="#定理418" title="Direct link to heading">​</a></h4><blockquote><p>Kruskal’s  Algorithms 會產生G的MST。</p></blockquote><h5 class="anchor anchorWithStickyNavbar_mojV" id="證明-4">證明<a class="hash-link" href="#證明-4" title="Direct link to heading">​</a></h5><p>考慮任何被此演算法加入的邊e = (v,w) ，讓集合S是在e被加入之前v有一條路徑P上的所有點集合。因為加入e也不會形成cycle，所以代表v屬於S且w不屬於S。此外，目前尚未有S到V-S的邊，因為那樣的邊可以被加入且不造成cycle，那麼應該已經被加入了。所以e是成本最低的邊，且連接S和V-S，根據cut property，e屬於任何MST。</p><p>所以如果我們可以顯示輸出結果（V,T）是G的ST，就完成證明了。首先因為演算法的設計，所以（V,T）沒有cycle。（V,T）是否會不connected？不。（V,T）不connected就代表會被分成至少兩個components S和V-S，且沒有edge可與他們相連，而這違法演算法的設計：因為G是connected，至少會有一條邊連接他們，當遇到時演算法會將此邊加入。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="the-optimality-of-prims-algorithms">The Optimality of Prim’s Algorithms<a class="hash-link" href="#the-optimality-of-prims-algorithms" title="Direct link to heading">​</a></h4><h4 class="anchor anchorWithStickyNavbar_mojV" id="定理410">定理4.10<a class="hash-link" href="#定理410" title="Direct link to heading">​</a></h4><blockquote><p>Prim’s  Algorithms 會產生G的MST。</p></blockquote><h5 class="anchor anchorWithStickyNavbar_mojV" id="證明-5">證明<a class="hash-link" href="#證明-5" title="Direct link to heading">​</a></h5><p>我們將此演算法找到的解稱為S。用反證法，先假設S不是最小成本，令ES={e1,e2,...,en-1}為演算法產生的邊。U為MST，該MST含有數條邊，為ES序列前最長可能集合（it&#x27;s a longest prefix of ES）。ei = {x,y}是演算法中第一條不屬於U被加入S的邊，讓W是點集合在ei加入之前，也代表U包含邊e1,e2,...,ei-1，但不包含ei。</p><p>在U當中必定存在一path使得x可到y，所以讓(a,b)是這條路徑上的第一條邊，其中a在W，b在W之外，如下圖</p><p><img src="/assets/images/greedy8-97a39e3f4c3cfb11fb60b7906a2affb8.jpg" width="620" height="347"></p><p>定義T = U + {x,y} - {a,b}，且T是G的ST，對 {x, y} 、{a, b}這兩條邊的成本考慮下面三種可能的情形：</p><ol><li><p>w({x, y}) &gt; w({a, b})</p><p>{a,b}成本較小，所以演算法在此步驟應會選擇{a,b}，違反{x,y}的假設。</p></li><li><p>w({x, y}) = w({a, b})</p><p>W(T) = W(U)，所以T也是MST。此外，演算法尚未選到邊{a,b}，這條邊不會是e1,e2,...,ei-1的其中一個，代表T包含e1,e2,...,ei，是一條比U還長的組合，違反tree U的定義。</p></li><li><p>w({x, y}) &lt; w({a, b})</p><p>加入了成本較小的邊，W(T) &lt; W(U)，但這不可能，因為U是MST。</p></li></ol><p>因為所有可能的情況都會造成矛盾，所以可知原始假設S非MST是錯誤的。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="the-optimality-of-reverse-delete-algorithm">The Optimality of Reverse-Delete Algorithm<a class="hash-link" href="#the-optimality-of-reverse-delete-algorithm" title="Direct link to heading">​</a></h4><h4 class="anchor anchorWithStickyNavbar_mojV" id="定理421">定理4.21<a class="hash-link" href="#定理421" title="Direct link to heading">​</a></h4><blockquote><p>Reverse-Delete Algorithms 會產生G的MST。</p></blockquote><h5 class="anchor anchorWithStickyNavbar_mojV" id="證明-6">證明<a class="hash-link" href="#證明-6" title="Direct link to heading">​</a></h5><p>考慮一條被此演算法移除的邊e = {v,w}，在他被移除的時候，他是存在Cycle C當中的。因為他是被演算法移除的邊，代表他是當下所有選擇中成本最高的邊，根據Cycle property，這條邊必定不屬於任何MST。</p><p>所以我們只要證明Reverse-Delete的輸出（V , T）是G的ST就完成了。首先（V , T）是connected，因為演算法不會刪除邊使得G變成disconnected。另外用反證法證明（V , T）不含cycle。假設（V , T）含有cycle C，考慮C上成本最高的邊e，這條邊是演算法碰到的第一個碰到的情形，這條邊應該被移除，因為不會造成圖G變成disconnected，這樣違反了Reverse-Delete的行為。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="sum-up-1">Sum up<a class="hash-link" href="#sum-up-1" title="Direct link to heading">​</a></h4><p>最後我們要來消除 <strong>所有邊的成本都是獨一無二的</strong>這個假設。</p><p>有一個簡單的方法就是：將每一條邊的成本都加上一些不同的極小數字，讓他們可以變得獨一無二。現在原先有的邊的成本排序並不會被打亂，因為加入的成本非常非常小，只是足以讓有相同成本的邊變得有一點點不同。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="實行prims-algorithm">實行Prim&#x27;s Algorithm<a class="hash-link" href="#實行prims-algorithm" title="Direct link to heading">​</a></h3><p>如果有好的資料結構可以是O(mlogn)。</p><p>雖然證明正確性的方式和Dijkstra&#x27;s 差很多，但是在實行上基本是相同的。我們一樣要決定哪一點應該被加入S當中，所以也是利用priority queue，共執行n-1次迴圈，每一回都都取出最小的並維持queue得正確性。 <strong>O(m)+取出最小值並回復成heap的時間</strong> = O(mlogn)</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="實行kruskals-algorithm--the-union-find-data-structure">實行Kruskal&#x27;s Algorithm : The Union-Find Data Structure<a class="hash-link" href="#實行kruskals-algorithm--the-union-find-data-structure" title="Direct link to heading">​</a></h3><p>在<!-- -->[3]<!-- -->Graph時有用過BFS、DFS都可以幫我們找到G的connected components。在Kruskal&#x27;s Algorithm中會有些不同，因為我們會&quot;動態&quot;增加新的點到G當中，我們並不會希望每次都需要重新計算，因此我們需要使用叫做 <strong>Union-Find</strong>的資料結構。簡單來說，當我們要將e=(v,w)加入S時，需要辨認v和w是否已有相連，暫且稱v和w都有其&quot;身分認證&quot;，若兩者身分相同代表已相連，則不加入e；若兩者身分不同，則將e加入。另外，加入後還需要有快速地方法將v和w的身分認證更新為相同的。其中，確認身分的行為稱為 <strong>Find</strong>；更新身分稱為 <strong>Union</strong>。</p><ul><li>MakeUnionFind(S) : 對集合S使用，回傳給我們Union-Find的資料結構，也就是說S當中的每一元素都被劃分成一個只包含自己的集合。這一步希望可以在O(n)的時間內完成，n=|S|。</li><li>對於S當中每一元素u，Find(u)會回傳包含u的這一集合的名稱。希望是O(logn)，甚至可以是O(1)。</li><li>對於兩集合A、B，Union(A,B)會改變資料結構 : 合併集合AB成為單一集合。希望是O(logn)。</li></ul><h4 class="anchor anchorWithStickyNavbar_mojV" id="a-simple-data-structure">A simple Data Structure<a class="hash-link" href="#a-simple-data-structure" title="Direct link to heading">​</a></h4><p>一個可能是最簡單的方式 : 用一陣列儲存。</p><p>S={1,2,...,n}是有n個元素的集合，設定一陣列 <strong>Component<!-- -->[n]</strong>，而component<!-- -->[s]<!-- -->就是含有s的集合的名稱。</p><ul><li><p>MakeUnionFind(S) </p><p>初始化一陣列，其中對於所有屬於S的s，component<!-- -->[s]<!-- --> = s 。</p></li><li><p>Find(s) </p><p>O(1)</p></li><li><p>Union(A,B)</p><p>至多需要O(n)，因為我們要去改集合A、B中所有元素s的component<!-- -->[s]<!-- -->的值。</p></li></ul><p>Union這一步驟可以做一些改善，例如其實我們只需要改A或B其中一個的components的值，其中，又可以去記錄說集合A、B哪一個擁有的元素較少，這樣改起來比較有效率，但最差的情況仍有可能是O(n)，不過這並不常發生，所以我們想要更精確地去描述所需要的時間。與其用the worst-case去界定 <strong>單一是Union operation</strong> 的執行時間的上限，我們以 <strong>一執行k次Union operations程序的總時間（或平均）</strong>。</p><h5 class="anchor anchorWithStickyNavbar_mojV" id="定理423">定理4.23<a class="hash-link" href="#定理423" title="Direct link to heading">​</a></h5><blockquote><p>考慮大小為n的集合S是一用陣列執行Union-Find的資料結構，且unions使用較大的集合作為名稱。MakeUnionFind需要O(n)；Find需要O(1)；任一執行k次Union operations的程序至多需要O(klogk)的時間。</p></blockquote><h5 class="anchor anchorWithStickyNavbar_mojV" id="證明-7">證明<a class="hash-link" href="#證明-7" title="Direct link to heading">​</a></h5><p>再提一次，一開始我們將S中n個元素都分為只包含自己的集合（因此共n個集合）。一次的Union動作至多牽涉2個這些原本只包含一元素的集合，所以在執行任k次Union程序後，至多2k個元素完全沒有被動過。現在考慮一特別的元素v，當v的集合參與了Union後，集合一定會變大。在Union時，一定有時候component<!-- -->[v]<!-- -->的值會被新，有些時候不會。但依據我們的慣例，使用較大的集合之名稱去做更改，所以每次更新component<!-- -->[v]<!-- -->時，擁有v的集合的大小會至少變為兩倍。集合v大小從1開始，最大為2k（因為前面所說至多剩下2k個完全沒動過的元素）。因此component<!-- -->[v]<!-- -->至多更新log(2K)次（log底數為2）在整個過程中。另外，至多2K個元素參與Union。所以得到上界為O(klogk)。</p><p>這樣的平均值行時間對於許多應用已經可以接受，但是我們可以試著改善，減少worst-case發生時會需要那麼多時間的成本，此方法也相對會需要提升Find到O(logn)。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="a-better-data-structure">A Better Data Structure<a class="hash-link" href="#a-better-data-structure" title="Direct link to heading">​</a></h4><p>使用指標（pointer），每一點都會有依靠指標指到自己的集合紀錄。</p><ul><li><p>MakeUnionFind(S):</p><p>將S內各元素u的指標指向自己（也就是目前他們屬於自己這個集合）。</p></li><li><p>Union : </p><p><strong>Union by rank</strong> : 用較小的tree去接較大的tree，如此一來會比較扁平，比較容易找到要找的元素</p><p><img src="/assets/images/greedy9-650a538f30fe6e9e174df4999f72a3fa.jpg" width="330" height="295"></p></li><li><p>Find:</p><p><strong>path compression</strong> : 指的是如下圖，當我們在find(6)=5後，讓從6找到5時所經過的所有點也都直接指向5，也可以讓結構變得更扁平。</p><p><img src="D:%5C110-2%E6%BC%94%E7%AE%97%E6%B3%95%5Cgreedy10.jpg"></p></li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="實行kruskals-algorithm">實行Kruskal&#x27;s Algorithm<a class="hash-link" href="#實行kruskals-algorithm" title="Direct link to heading">​</a></h3><p>如果有好的資料結構可以是O(mlogn)。</p><div class="codeBlockContainer_I0IT language-pseudocode theme-code-block"><div class="codeBlockContent_wNvx pseudocode"><pre tabindex="0" class="prism-code language-pseudocode codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">Kruskal&#x27;s (G,c)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1.{e1,e2,...,em}=sorted edges in ascending order</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2.T=∅</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3.For each ei = (u,v)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4.  if(u and v are not connected by edges in T)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5.      T=T+{ei}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h5 class="anchor anchorWithStickyNavbar_mojV" id="使用-unionfind">使用 UnionFind<a class="hash-link" href="#使用-unionfind" title="Direct link to heading">​</a></h5><ul><li><p>將每一connected component維持為一不相交的集合（disjoint set）</p></li><li><p>Line1 : Sort edge cost </p><p>需要O(mlogm)，因為兩點間至多就一條邊，因此m≦n^2，所以也可說是O(mlogn)</p></li><li><p>Line4 : 查看Find(u)和Find(v)是否相異，代表可以合併。（至多2m次）</p></li><li><p>Line5: Union(u,v) （至多n-1次）</p></li></ul><p>時間複雜度 O(mlogn)</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/yehs1225/yehs1225.github.io/docs/Algorithm/Algorithm[4_2].md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_foO9"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/Algorithm/Algorithm[4_1]"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">[4.1]Greedy Algorithms - Analysis</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/Algorithm/Algorithm[5]"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">[5]Divide and Conquer</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#shortest-path" class="table-of-contents__link toc-highlight">Shortest Path</a><ul><li><a href="#設計演算法" class="table-of-contents__link toc-highlight">設計演算法</a></li><li><a href="#分析演算法" class="table-of-contents__link toc-highlight">分析演算法</a></li><li><a href="#實行與時間複雜度" class="table-of-contents__link toc-highlight">實行與時間複雜度</a></li></ul></li><li><a href="#mst" class="table-of-contents__link toc-highlight">MST</a><ul><li><a href="#設計演算法-1" class="table-of-contents__link toc-highlight">設計演算法</a></li><li><a href="#分析演算法---性質" class="table-of-contents__link toc-highlight">分析演算法 - 性質</a></li><li><a href="#分析演算法---正確性" class="table-of-contents__link toc-highlight">分析演算法 - 正確性</a></li><li><a href="#實行prims-algorithm" class="table-of-contents__link toc-highlight">實行Prim&#39;s Algorithm</a></li><li><a href="#實行kruskals-algorithm--the-union-find-data-structure" class="table-of-contents__link toc-highlight">實行Kruskal&#39;s Algorithm : The Union-Find Data Structure</a></li><li><a href="#實行kruskals-algorithm" class="table-of-contents__link toc-highlight">實行Kruskal&#39;s Algorithm</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Tzu Hsuan Yeh. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.53e15555.js"></script>
<script src="/assets/js/main.e50ce15c.js"></script>
</body>
</html>