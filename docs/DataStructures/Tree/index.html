<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Yeh&#39;s blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Yeh&#39;s blog Atom Feed"><title data-react-helmet="true">Tree | Yeh&#x27;s blog</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://your-docusaurus-test-site.com/docs/DataStructures/Tree"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Tree | Yeh&#x27;s blog"><meta data-react-helmet="true" name="description" content="樹的概念"><meta data-react-helmet="true" property="og:description" content="樹的概念"><link data-react-helmet="true" rel="icon" href="/img/favicon.png"><link data-react-helmet="true" rel="canonical" href="https://your-docusaurus-test-site.com/docs/DataStructures/Tree"><link data-react-helmet="true" rel="alternate" href="https://your-docusaurus-test-site.com/docs/DataStructures/Tree" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://your-docusaurus-test-site.com/docs/DataStructures/Tree" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.f2b17ad4.css">
<link rel="preload" href="/assets/js/runtime~main.beb046ae.js" as="script">
<link rel="preload" href="/assets/js/main.5c1be6b3.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/favicon.png" alt="My Site Logo" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/favicon.png" alt="My Site Logo" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">My Site</b></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/intro">Notes</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/yehs1225" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">🌜</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">🌞</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_P2Lg"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_rKC_"><div class="sidebar_CW9Y"><nav class="menu thin-scrollbar menu_SkdO"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">Notes Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/Algorithm/Algorithm[1]">Algorithm</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/BasicKnowlege/CSS-RWD切版練習">BasicKnowlege</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active hasHref_VCh3" aria-current="page" href="/docs/DataStructures/Graph">DataStructures</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/DataStructures/Graph">Graph圖形</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/DataStructures/Recursion">Recursion</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/DataStructures/Sorting排序">Sorting排序</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/DataStructures/Tree">Tree</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/Django/[DJ]Deploy">Django</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/Docker/Docker1基本介紹">Docker</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/JavaScript/JavaScript-this">JavaScript</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/Reactjs/React_ES6">Reactjs</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/Tools/Command-Line-and-Vim">Tools</a></div></li></ul></nav></div></aside><main class="docMainContainer_TCnq"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="docItemContainer_vinB"><article><div class="tocCollapsible_jdIR theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_Fzxq">On this page</button></div><div class="theme-doc-markdown markdown"><h1>Tree</h1><h2 class="anchor anchorWithStickyNavbar_mojV" id="樹的概念">樹的概念<a class="hash-link" href="#樹的概念" title="Direct link to heading">​</a></h2><p>樹是一種重要的<strong><em>離散</em></strong>結構(discrete structure)，提供「<strong><em>具有層次關係</em></strong>」的概念來結構資料。生活中常見的樹有「族譜」、「演化樹」、「組織架構」、「運算樹」等等。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="專有名詞">專有名詞<a class="hash-link" href="#專有名詞" title="Direct link to heading">​</a></h3><h4></h4><blockquote><p><strong>定義</strong></p><p>樹為節點組成的有限集合，其中</p><p>(1) 存在一特殊節點R稱為樹根(root)</p><p>(2) 其他節點可分成n個無交集的集合:T1,T2,...,Tn，n≧=0，而T1,T2,...,Tn 本身皆為樹，稱其為R的子樹(subtree)</p></blockquote><p>在定義中，各子樹T1,T2,...,Tn亦沿用了樹的定義(遞迴)。</p><p>圖1描繪了一棵「有根樹」(rooted tree)，並搭配下列名詞簡介(下文若無特別強調皆為此類樹)；圖2為「無根樹」(unrooted tree)，常在不需考量節點間資料關係時使用(亦即無階層概念)。</p><p><img alt="圖12 一棵樹" src="/assets/images/tree1-08690da5fa894728a6c86c41ff672172.jpg" width="1576" height="704"></p><ul><li>node 節點: 圓圈所標明之資料及向下分支的合稱。共16個。</li><li>root根 : node A 。</li><li>degree分支度 : 一個node的所有子樹的數目。例如A的degree為3、C為1，D為2。一棵樹的degree為其所有node中degree最大者，圖1即為3。</li><li>leaf (or terminal node ) : degree為0的node(即其無任何子樹)，如GHKLMNOP。</li><li>non-terminal node : 任何非termianl node。</li><li>child (son) : 任何節點之子樹的樹根。BCD皆為A的son。</li><li>father(parent) : A為BCD的father。</li><li>sibling(brother) : 共有一個father之node。例如BCD、EFG。</li><li>ancestor : 任一節點走向樹根所經過的所有節點。例如L的ancestor為FBA。</li><li>descendant : 任一節點的所有子樹節點。例如D的descendant為IJNOP。</li><li>level(l) :   定義階層l枝節點其son的階層為l+1。</li><li>depth(height) : 樹的最高階層。圖1為4。</li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="樹的表示方法">樹的表示方法<a class="hash-link" href="#樹的表示方法" title="Direct link to heading">​</a></h2><p>陣列可表示樹，然而會較為困難。此以鏈結串列(linked list)表示，假設一棵樹T的分支度為K，即T中存在節點X其分支度為k，為使鏈結節點可存放X點的k個子數指標。每個節點須有k個指標的記憶體位置，若此樹有n個節點則需要nk個指標位置。然而除了root以外，每個節點僅需一個指標指向，亦即只需n-1個指標位置，因此多用的空間為nk-(n-1)=n(k-1)+1，非常浪費空間。於是介紹下列三種表示方法:一般化串列、左子右兄弟、分支度為2的表示法。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="一般化串列表示法gernalized-list">一般化串列表示法(gernalized list)<a class="hash-link" href="#一般化串列表示法gernalized-list" title="Direct link to heading">​</a></h3><p>之前學到的串列可用A=(a1,a2,...,an)表示，為有限且有序之集合；每元素ai，1≦i≦n，皆有相同資料型態。若不限定須有相同資料型態則稱為一般化串列(gernalized list)，於是a可以是node也可以是tree，因此用其來表示一棵樹T :</p><blockquote><p>T = (R,T1,T2, ... ,Tn)</p></blockquote><p>T1,T2, ... ,Tn為R的子樹，Ti可能為節點或樹(遞迴)。</p><p><strong>範例</strong></p><p>圖1的一棵樹可表示成一般串列如下:</p><blockquote><p>T = (A,(B,(E,K),(F,L,M),G),(C,H),(D,(I,N),(J,O,P)))</p></blockquote><p>若將節點A的三個兒子BCD所形成之子樹，分別取名為T1,T2,T3則可簡化為</p><blockquote><p>T=(A,T1,T2,T3) ，其中</p><p>T1 = (B,(E,K),(F,L,M),G)</p><p>T2 = (C,H)</p><p>T3 = (D,(I,N),(J,O,P))</p></blockquote><p>如圖3串列中的元素可能是某一樹上的節點或一子樹；而圖4鏈結節點中的欄位也有可能是樹節點資料R，也可能是子樹Ti(1&lt;=i&lt;=n)的指標，因此可新增一個節點欄位tag來區別。在C語言中可用union來達成節點宣告。</p><p><img alt="圖34 一般化串列" src="/assets/images/tree2-45104d5c890a07995c3b604ceeaaa793.jpg" width="1291" height="667"></p><p><strong>union節點宣告</strong></p><div class="codeBlockContainer_I0IT language-c++ theme-code-block"><div class="codeBlockContent_wNvx c++"><pre tabindex="0" class="prism-code language-c++ codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">struct TreeNode</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int tag;//用tag區分,欄位node的資料型態</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //union:編譯器在編譯階段會預留空間(int or  struct TreeNode指標中較大者))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    union</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        struct TreeNode *Tlink;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct TreeNode *link;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><strong>實作結果示意圖</strong></p><p><img alt="圖5 一般化鏈結表示" src="/assets/images/tree3-b91991a26f524c1366544e7add8b7448.jpg" width="1986" height="447"></p><h3 class="anchor anchorWithStickyNavbar_mojV" id="左子右兄弟表示法">左子右兄弟表示法<a class="hash-link" href="#左子右兄弟表示法" title="Direct link to heading">​</a></h3><p>觀察圖1的樹，可以發現每個節點都有唯一的 <strong>最左兒子(leftmost child)</strong>；也有一個最靠近它的<strong>右兄弟(rightmost sibling)</strong>，圖1可轉換成圖6，每個節點結構為圖7；，鏈節串列如圖8。
<img alt="圖67 一般化鏈結表示" src="/assets/images/tree4-cebef04d3a78a4615568c910af522fe3.jpg" width="1318" height="451">
<img alt="圖8 一般化鏈結表示" src="/assets/images/tree5-9d11cebcce6117260bbbcd23e89bd6e8.jpg" width="956" height="493"></p><h3 class="anchor anchorWithStickyNavbar_mojV" id="分支度為2的表示法">分支度為2的表示法<a class="hash-link" href="#分支度為2的表示法" title="Direct link to heading">​</a></h3><p>將左子右兄弟稍微旋轉可以得到degree為2的樹，稱為二元樹(binary tree)(圖9)。二元數可以用來表示任何樹!
<img alt="圖8 一般化鏈結表示" src="/assets/images/tree6-2d4fc22a90bf502b786176fc7c220463.jpg" width="1198" height="695"></p><h2 class="anchor anchorWithStickyNavbar_mojV" id="二元樹">二元樹<a class="hash-link" href="#二元樹" title="Direct link to heading">​</a></h2><p>二元樹結構簡單且容易表示(可用陣列或鏈結串列表示)，更有許多有用的性質，且任何樹皆可用此表示!因此是一項非常重要的資料結構。任一節點最多有兩分支且有<strong>左右之分</strong>。</p><blockquote><p><strong>定義</strong></p><p>二元樹是一個由節點組成的有限集合，可以是空集合，或是包含了</p><p>(1) 一個樹根節點；</p><p>(2) 其他節點分割成兩個沒有交集的二元樹 : 一為左子樹(left subtree)；一為右子樹(right subtree)。  </p></blockquote><p>樹與二元樹間的差異:</p><ol><li>樹不可有空節點，而二元樹可以。</li><li>樹的子樹沒有順序，而二元數的子樹有左右之分。</li></ol><p><strong>範例</strong>
<img alt="圖11" src="/assets/images/tree7-4a780f55eaab017aab04fd38b552c079.jpg" width="544" height="305"></p><h4 class="anchor anchorWithStickyNavbar_mojV" id="樹和二元樹的共同基本性質">樹和二元樹的共同基本性質<a class="hash-link" href="#樹和二元樹的共同基本性質" title="Direct link to heading">​</a></h4><blockquote><p>定理 1: 若一棵樹T的總節點樹為V，總邊樹為E，則 V=E+1。</p></blockquote><h4 class="anchor anchorWithStickyNavbar_mojV" id="二元樹的性質">二元樹的性質<a class="hash-link" href="#二元樹的性質" title="Direct link to heading">​</a></h4><p>二元數可容納的節點樹與深度似乎有極大關係。圖12的特殊例子表示兩種樹 - 完備二元樹(complete binary tree) 及 歪斜樹(skew tree) ，兩者具有同樣的節點數，然而歪斜數需要較多階層來存放。</p><p><img alt="圖11" src="/assets/images/tree8-d057bee5ea0d1ca5a4e10b3d3cd360c4.jpg" width="995" height="447"></p><blockquote><p>定理 1 :</p><p>(1) 二元樹上階層i的節點數目最多為2^(i-1)，i≦1;</p><p>(2) 深度為k的二元樹，其節點數目最多為2^k -1，k≧1。</p></blockquote><blockquote><p>定理 2 : </p><p>若T為一非空的二元樹，n0為樹葉節點數目，n2為分支度為2的節點數目，則n0=n2+1。</p></blockquote><p><strong>完滿二元樹(full binary tree)</strong></p><blockquote><p>定義 : 一個深度為k的完滿二元樹即為一深度為k且有2^k -1個節點的二元樹，k≧0。</p></blockquote><p><strong>完備二元樹(complete binary tree)</strong></p><blockquote><p>定義 : 深度為k，節點數為n的二元樹為完備二元樹，若且唯若 : </p><p>(1) k=1時，樹有一個節點；</p><p>(2) 當k≧2且1≦ i &lt; k時，深度 i 有 2^(i-1) 個節點，且第k層的節點皆由第k-1層的分支由左至右逐一連接而成。</p></blockquote><p>By定義，缺口一定在右下角。</p><p>由定理1可得</p><blockquote><p>n 個節點的完備或完滿二元樹，其深度為<!-- -->[log2(n+1)]<!-- --> (高斯取頂符號打不出來@@)</p></blockquote><p><strong>正規二元樹(formal binary tree)</strong></p><p>常用於單淘汰賽制，由定理2 : n0=n2+1，可推導出單淘汰賽制中自n個隊伍中產生冠軍須舉辦n-1場比賽。</p><blockquote><p>定義 : 若二元樹中internal node內部節點(亦即所有非樹葉的節點)恰有兩個子節點。</p></blockquote><h3 class="anchor anchorWithStickyNavbar_mojV" id="二元樹表示法">二元樹表示法<a class="hash-link" href="#二元樹表示法" title="Direct link to heading">​</a></h3><p>用陣列表示樹很不方便，而二元樹結構較單純，可用陣列來表示。以下將以陣列及鏈節串列兩種方式表示二元樹。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="陣列表示二元樹">陣列表示二元樹<a class="hash-link" href="#陣列表示二元樹" title="Direct link to heading">​</a></h4><blockquote><p>定理1 : 若有一個具有n個節點的<strong>完備二元樹</strong>以循序的方式編號，並依序存放在陣列A中，即第i個節點存放在A<!-- -->[i]<!-- -->中，1≦i≦n，則</p><p>(1) 節點i的父親節點位在A<!-- -->[i/2]<!-- -->中，i≠1(i=1時，其節點正為樹根，無父節點)。</p><p>(2) 若2i≦n，節點i的左兒子節點位在A<!-- -->[2i]<!-- -->處；若2i&gt;n，節點i沒有左兒子節點。</p><p>(3) 若2i+1≦n，節點i的右兒子節點位在A<!-- -->[2i+1]<!-- -->處；2i+1&gt;n，節點i沒有右兒子節點。</p></blockquote><p>依上述定理，將圖12的樹存放在陣列中如圖13，可以發現歪斜樹會浪費空間及時間，深度為k的二元樹擁有2^k -1個可放節點的空間，若存放深度k的歪斜樹只用到k個空間!</p><p><img alt="圖13" src="/assets/images/tree9-2619a0bc83edd49dc363587f27a47dc0.jpg" width="1934" height="785"></p><h4 class="anchor anchorWithStickyNavbar_mojV" id="鏈節串列表示二元樹">鏈節串列表示二元樹<a class="hash-link" href="#鏈節串列表示二元樹" title="Direct link to heading">​</a></h4><p>陣列表示完備二元樹以相當方便，但是使用陣列時如果資料需要頻繁的新增刪除則會非常耗時，因此可嘗試以鏈結串列表示(圖14)。可用一指標root指向樹根，作為樹鏈節串列的起點。圖13和14比較可以發現完備二元樹在兩種方法都較不會浪費空間；而歪斜樹的陣列表示法可能需要2^n -1個陣列元素，串列僅需n個，所以有2^n -1-n的空間被浪費。</p><p>圖14的節點結構在取得兒子節點的指標很方便，但是父節點的取得則無法滿足，因此可依需求自行定義鏈結節點，加上一欄位指向父節點。此外，可以發現樹葉向下指的兩個指標皆會指向NULL，這項特性引發了引線二元樹的靈感(下面會提到)。</p><p><img alt="圖14" src="/assets/images/tree10-f1d08f77b5eccf481ebed2e2c98efed4.jpg" width="1656" height="786"></p><h2 class="anchor anchorWithStickyNavbar_mojV" id="二元樹走訪">二元樹走訪<a class="hash-link" href="#二元樹走訪" title="Direct link to heading">​</a></h2><p>對全資料做動作例如:計算所有數目、印出所有資料、在所有資料中搜尋某項資料...等時，即需要對二元樹進行走訪(traversal)運算，再走訪的同時進行計算列印或搜尋等動作，希望發展的走訪演算法可以對每一節點皆一致，方便撰寫程式實作。</p><p>以圖15為例，若對一樹節點而言，V代表處理節點資料，L代表走訪其左子樹，R代表走訪其右子樹，共有六種走訪組合，又因對稱的緣故，可以只考慮左子樹一定會先於右子樹被走訪，因此剩下三種順序，以V對應位置取名。</p><p><img alt="圖15" src="/assets/images/tree11-bfae417ff045a9d984608ebd41cefc0b.jpg" width="1598" height="370"></p><p><strong>節點結構宣告</strong></p><div class="codeBlockContainer_I0IT language-c++ theme-code-block"><div class="codeBlockContent_wNvx c++"><pre tabindex="0" class="prism-code language-c++ codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">struct BTreeNode</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  struct BTreeNode *leftchild;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  char data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  struct BTreeNode *rightchild;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct BTreeNode *root;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>圖16為運算是利用三種方式走訪之結果，可以發現就是利用遞迴的方式，事實上，二元樹的建構也是建立在遞迴觀念之上。</p><p><img alt="圖16" src="/assets/images/tree12-bac8a93b5b2175921e6d27324f4fc253.jpg" width="1438" height="587"></p><p><strong>中序走訪LVR</strong></p><div class="codeBlockContainer_I0IT language-c++ theme-code-block"><div class="codeBlockContent_wNvx c++"><pre tabindex="0" class="prism-code language-c++ codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">void inoreder(struct BTreeNode *node)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(node!=NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        inorder(node-&gt;leftchild);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cout&lt;&lt;node-&gt;data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        inorder(node-&gt;rightchild);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><strong>後序走訪LRV</strong></p><div class="codeBlockContainer_I0IT language-c++ theme-code-block"><div class="codeBlockContent_wNvx c++"><pre tabindex="0" class="prism-code language-c++ codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">void postoreder(struct BTreeNode *node)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(node!=NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        postoreder(node-&gt;leftchild);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        postoreder(node-&gt;rightchild);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cout&lt;&lt;node-&gt;data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><strong>前序走訪VLR</strong></p><div class="codeBlockContainer_I0IT language-c++ theme-code-block"><div class="codeBlockContent_wNvx c++"><pre tabindex="0" class="prism-code language-c++ codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">void preorder(struct BTreeNode *node)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(node!=NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cout&lt;&lt;node-&gt;data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        preorder(node-&gt;leftchild);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        preorder(node-&gt;rightchild);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>藉由以上程式碼，基本上要得到走訪結果僅需呼叫<code>inorder(root);</code>、<code>preorder(root);</code>、<code>postorder(root);</code>需注意的是中序走訪還須加上必要的括號，以得到正確運算式。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="利用堆疊和迴圈方式實作">利用堆疊和迴圈方式實作<a class="hash-link" href="#利用堆疊和迴圈方式實作" title="Direct link to heading">​</a></h4><p><strong>中序走訪LVR</strong></p><div class="codeBlockContainer_I0IT language-c++ theme-code-block"><div class="codeBlockContent_wNvx c++"><pre tabindex="0" class="prism-code language-c++ codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">//宣告節點構造</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct BTreeNode</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  struct BTreeNode *leftchild;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  char data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  struct BTreeNode *rightchild; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct BTreeNode *root;//指向樹根</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//宣告堆疊元素結構</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct stackNode</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct BTreeNode *treenode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct stackNode *next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct StackNode *top;//指向堆疊頂端</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//push</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void push_StackNode(BTreeNode *node)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct stackNode *oldtop;//新指標存舊的top</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    oldtop = top;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    top = (struct stackNode*)malloc(sizeof(struct stackNode));//分配空間給新節點</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    top-&gt;treenode = node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    top-&gt;next = oldtop;//新節點連向舊節點</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct BTreeNode *pop_StackNode()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(top==NULL)//stack is empty</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        StackIsEmpty();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        struct stackNode *node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        struct stackNode *oldtop;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        oldtop = top;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        node = top-&gt;treenode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        top = top-&gt;next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        free(oldtop);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void inorder_Stack(struct BTreeNode *node)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{   do</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(node!=NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            push_StackNode(node);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            node = node-&gt;leftchild;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }//push all leftchild</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(top!=NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            node = pop_StackNode();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            cout&lt;&lt;node-&gt;data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            node = node-&gt;rightchild;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }//print data and check rightchild</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } while(top!=NULL || node!=NULL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><strong>前序走訪VLR</strong></p><p>中序和前序的差異僅在:輸出V的時機，中序遇到V時先放入堆疊去找左子節點；前序則直接印出。所以可以用中序的概念去修改實作出。</p><div class="codeBlockContainer_I0IT language-c++ theme-code-block"><div class="codeBlockContent_wNvx c++"><pre tabindex="0" class="prism-code language-c++ codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">void preorder_Stack(struct BTreeNode *node)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{   do</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(node!=NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {   cout&lt;&lt;node-&gt;data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            push_StackNode(node);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            node = node-&gt;leftchild;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }//push all leftchild</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(top!=NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            node = pop_StackNode();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            node = node-&gt;rightchild;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }//print data and check rightchild</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } while(top!=NULL || node!=NULL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><strong>後序走訪LRV</strong></p><p>LRV反轉後即為VRL，反之亦然，因此可以先求出VRL結果再進行反轉。好處在於VRL可以用上面取得前序(VLR)的方法來實作，我們多宣告<code>push_data(node)</code>、<code>pop_data()</code>、<code>top_data</code>來實作。</p><div class="codeBlockContainer_I0IT language-c++ theme-code-block"><div class="codeBlockContent_wNvx c++"><pre tabindex="0" class="prism-code language-c++ codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">struct StackNode *top_data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void push_data(struct BTreeNode *node)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct StackNode *oldtop_data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    oldtop_data = top_data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    top_data = (struct stackNode*)malloc(sizeof(struct stackNode));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    top_data-&gt;data = node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    top_data-&gt;next = oldtop_data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct StackNode *pop_data()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(top_data==NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        StackisEmpty();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        struct BTreeNode *node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        struct StackNode *oldtop_data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        oldtop_data = top_data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        node = top_data-&gt;data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        top_data=top_data-&gt;next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        free(oldtop_data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void postorder_Stack(struct BTreeNode *node)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{   do</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(node!=NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {   push_data(node);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            push_StackNode(node);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            node = node-&gt;rightchild;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }//push all leftchild</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(top!=NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            node = pop_StackNode();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            node = node-&gt;leftchild;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }//print data and check rightchild</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } while(top!=NULL || node!=NULL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while(top_data!=NULL) cout&lt;&lt;pop_data();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="階層走訪level-order-traversal">階層走訪(level-order traversal)<a class="hash-link" href="#階層走訪level-order-traversal" title="Direct link to heading">​</a></h4><p>走訪階層由小至大，同一階層則從左至右。對同一階層而言，先走訪的節點，其子節點也會在下一階層先被走訪，有FIFO的特性，用佇列queue來實做。</p><div class="codeBlockContainer_I0IT language-c++ theme-code-block"><div class="codeBlockContent_wNvx c++"><pre tabindex="0" class="prism-code language-c++ codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">//宣告節點構造</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct BTreeNode</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  struct BTreeNode *leftchild;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  char data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  struct BTreeNode *rightchild; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct BTreeNode *root;//指向樹根</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Qnode</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct BTreeNode *BTnode;//指向資料(為BTreeNode)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct Qnode *next;//指向下一個Qnode</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Qnode *front;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Qnode *rear;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void AddQueue(struct BTreeNode *Tnode)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct Qnode *node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    node = (struct Qnode *)malloc(sizeof(struct Qnode));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    node-&gt;BTnode = Tnode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    node-&gt;next = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(front==NULL)//new Queue</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        front = node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rear-&gt;next = node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    rear = node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct BTreeNode *DeleteQueue()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{   struct BTreeNode *node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct Qnode *oldfront;//存要被刪除元素的指標作為free用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(rear==NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        QisEmpty();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        oldfront = front;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        node = front-&gt;BTNode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        front = front-&gt;next;//front往下指</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        free(oldfront);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void LevelOrder(struct BTreeNode *node)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    AddQueue(node);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while(front!=NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        node = DeleteQueue();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cout&lt;&lt;node-&gt;BTnode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(node-&gt;leftchild!=NULL) AddQueue(node-&gt;leftchild);//依序走訪左右</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(node-&gt;rightchild!=NULL) AddQueue(node-&gt;rightchild);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="二元搜尋樹binary-search-tree">二元搜尋樹(binary search tree)<a class="hash-link" href="#二元搜尋樹binary-search-tree" title="Direct link to heading">​</a></h2><blockquote><p><strong>定義</strong></p><p>二元搜尋樹是一棵二元樹，可能是空二元樹，若不為空二元樹，則滿足下列性質:</p><p>(1) 所有節點內的資料性質是相異的 *(非必要，在此方便討論)。</p><p>(2) 左子節點的資料內容(如果有) 要比父子節點的資料內容小。*(和1有關)</p><p>(3) 右子節點的資料內容(如果有) 要比父子節點的資料內容大。*(和1有關)</p><p>(4)  以左和右子節點為樹根的左子樹和右子樹也是二元搜尋樹。(遞迴概念)</p></blockquote><p>依照定義，圖17中ab皆為二元搜尋樹，C則不。</p><p><img alt="圖17" src="/assets/images/tree13-373e6044f59af610aed9ab692cb80969.jpg" width="1699" height="533"></p><h4 class="anchor anchorWithStickyNavbar_mojV" id="搜尋資料">搜尋資料<a class="hash-link" href="#搜尋資料" title="Direct link to heading">​</a></h4><p>利用二元搜尋樹對資料大小排序非常明確的特質，可以在搜尋資料時更為方便，以下以遞迴及非遞迴的方式撰寫。非遞迴的方式會較有效率!若有保留走訪資訊的需求可以加入堆疊儲存資料。</p><p>計算時間複雜度時，考量最差情況為「愈搜尋資料根本不在樹裡」，因此為O(h)，h為樹高，若樹有共n個節點，則logn≦h≦n。由此可知樹的高度會影響搜尋速度，因此有學者提出「高度平衡樹」(AVL tree)，將樹的高度控制在logn，即可將時間控制在O(logn)，是非常重要的做法。</p><p>(以下二元搜尋樹定義為右子節點≧父節點、左子節點＜父節點。)</p><p><strong>遞迴搜尋</strong></p><div class="codeBlockContainer_I0IT language-c++ theme-code-block"><div class="codeBlockContent_wNvx c++"><pre tabindex="0" class="prism-code language-c++ codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">//declaration node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct BSTreeNode</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct BSTreeNode *leftchild;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct BSTreeNode *rightchild;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct BSTreeNode *root;//point to root</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct BSTreeNode *SearchBST(struct BSTreeNode *tree,int x)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(tree==NULL) return NULL;//not found</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(tree-&gt;data==x) return tree;//found</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(tree-&gt;data&lt;x) return SearchBST(tree-&gt;leftchild, x);//find at leftside</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return SearchBST(tree-&gt;rightchild, x);//otherwise find at rightside</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><strong>非遞迴搜尋</strong></p><div class="codeBlockContainer_I0IT language-c++ theme-code-block"><div class="codeBlockContent_wNvx c++"><pre tabindex="0" class="prism-code language-c++ codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">struct BSTreeNode *SearchBST_interative(struct BSTreeNode *node,int x)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while(node!=NULL)//if still have somewhere not searched,keep searching.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(node-&gt;data==x) return node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(node-&gt;data&lt;x) node = node-&gt;leftchild;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else node = node-&gt;rightchild;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }return NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="新增資料">新增資料<a class="hash-link" href="#新增資料" title="Direct link to heading">​</a></h4><p>插入資料進二元搜尋樹時，為維持資料大小關係，必須知道可以插入的位置!由於先前限定資料必相異，因此在插入資料時，可以先進行搜索，當搜尋結果為NULL時即為該插入的位置。因此，資料結構老師的名言:</p><blockquote><p>徐子曰 : 搜尋未果處，新增其也。</p></blockquote><p><strong>遞迴</strong></p><p>在程式中利用不斷搜尋遞迴呼叫，當節點被插入時會一層層的回傳直到根節點，讓節點的父親都能知道新增了一代!</p><div class="codeBlockContainer_I0IT language-c++ theme-code-block"><div class="codeBlockContent_wNvx c++"><pre tabindex="0" class="prism-code language-c++ codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">struct BSTreeNode *NewBSTNode(int x)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct BSTreeNode *node = (struct BSTreeNode *) malloc(sizeof(struct BSTreeNode));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    node-&gt;data = x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    node-&gt;leftchild = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    node-&gt;rightchild = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct BSTreeNode *InsertBSTnode(struct BSTreeNode *node,int x)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(node==NULL) return NewBSTNode(x);//搜尋未果處，新增其也</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(x&lt;node-&gt;data)//go left</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        node-&gt;leftchild = InsertBSTNode(node-&gt;leftchild,x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        node-&gt;rightchild = InsertBSTNode(node-&gt;leftchild,x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><strong>非遞迴</strong></p><p>「搜尋未果處，新增其也」的概念依舊沒變，然而父子的關係就必須手動進行維護!</p><div class="codeBlockContainer_I0IT language-c++ theme-code-block"><div class="codeBlockContent_wNvx c++"><pre tabindex="0" class="prism-code language-c++ codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">void BSTreeNode *InsertBSTnode_iterative(int x)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct BSTreeNode *father,*son;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    son = root;father=NULL;//init ；root is global variable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while(son!=NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        father = son;//記住父節點後，往下搜尋</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(x&lt;son-&gt;data) son = son-&gt;leftchild;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else son = son-&gt;rightchild;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //當node son ==NULL時，搜尋未果處，新增其也</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    son = (struct BSTreeNode *) malloc(sizeof(struct BSTreeNode));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    son-&gt;data = x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    son-&gt;leftchild =NULL; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    son-&gt;rightchild =NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(root==NULL) root = p;//first element in tree</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else if(x&lt;father-&gt;data) father-&gt;leftchild = son;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else father-&gt;righttchild = son;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="刪除資料">刪除資料<a class="hash-link" href="#刪除資料" title="Direct link to heading">​</a></h4><p>刪除二元搜尋樹上的資料時，會發現有三種情形(圖18)，以下將以遞迴及非遞迴的方式探討。</p><p><img alt="圖18" src="/assets/images/tree14-994e56793cea4c39b1356ea8833b149c.jpg" width="1704" height="533"></p><p><strong>遞迴</strong></p><ol><li><p>(a)刪除樹葉</p><p>直接將樹葉刪除，而其父節點因為遞迴的迴傳概念，也會接收到其子節點被改為NULL的情形。因此僅需下面步驟即可完成:</p><div class="codeBlockContainer_I0IT language-c++ theme-code-block"><div class="codeBlockContent_wNvx c++"><pre tabindex="0" class="prism-code language-c++ codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">//node為欲刪除節點</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">temp = node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">node = NULL;  //回傳時讓父節點知其Son為NULL</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">free(temp);</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div></li><li><p>(b)刪除有一子樹的節點</p></li></ol><p>   找到子樹的樹根取代即可。</p><div class="codeBlockContainer_I0IT language-c++ theme-code-block"><div class="codeBlockContent_wNvx c++"><pre tabindex="0" class="prism-code language-c++ codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">//node為欲刪除節點</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">temp = (node-&gt;leftchild) ? node-&gt;leftchild:node-&gt;rightchild; //確認Node的右或左子樹哪個存在</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*node = *temp;//取代被刪掉的位置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">free(temp);</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><ol start="3"><li><p>(c)刪除有兩子樹的節點</p><p>以<strong>其右子樹中的最左樹葉</strong>(稱為「中序直接後繼元素(in-order successor)」)取代可維持正確性。</p><div class="codeBlockContainer_I0IT language-c++ theme-code-block"><div class="codeBlockContent_wNvx c++"><pre tabindex="0" class="prism-code language-c++ codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">struct BSTreeNode *InOrderSucc(struct BSTreeNode *node)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{   struct BSTreeNode *p;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for(p=node;p-&gt;leftchild!=NULL;p=p-&gt;leftchild);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return p;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//delete</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">temp = InOrderSucc(node-&gt;rightchild);//找到中序直接後繼元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">node-&gt;data = temp-&gt;data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">node-&gt;rightchild = DeleteBSTNode(node-&gt;rightchild,temp-&gt;data);</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div></li></ol><p><strong>完整版</strong></p><div class="codeBlockContainer_I0IT language-c++ theme-code-block"><div class="codeBlockContent_wNvx c++"><pre tabindex="0" class="prism-code language-c++ codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain"> struct BSTreeNode *InOrderSucc(struct BSTreeNode *node)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> {  struct BSTreeNode *p;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     for(p=node;p-&gt;leftchild!=NULL;p=p-&gt;leftchild);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     return p;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> struct BSTreeNode *DeleteBSTNode(struct BSTreeNode *node,int x)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     struct BSTreeNode *temp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     if(node==NULL) return node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     //search</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     if(x&lt;node-&gt;data) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         node-&gt;leftchild = DeleteBSTree(node-&gt;leftchild,x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     else if(x&gt;node-&gt;data)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         node-&gt;rightchild = DeleteBSTree(node-&gt;rightchild,x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     //x found in node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     {  //sitaution a or b</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         if((node-&gt;leftchild==NULL)||(node-&gt;rightchild==NULL))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             temp = (node-&gt;leftchild)?node-&gt;leftchild:node-&gt;rightchild;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             if(temp==NULL)//a -&gt; leaf</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 temp = node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 node = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             else *node = *temp; // b -&gt; one subtre </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             free(temp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         else //c -&gt; two subtree</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             temp = InOrderSucc(node-&gt;rightchild);//找到中序直接後繼元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             node-&gt;data = temp-&gt;data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             node-&gt;rightchild = DeleteBSTNode(node-&gt;rightchild,temp-&gt;data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="heap-堆積">Heap 堆積<a class="hash-link" href="#heap-堆積" title="Direct link to heading">​</a></h2><p>Heap 是一種特殊的完備二元樹，節點與其子節點之間有定好的大小關係存在。分為以下兩種：</p><blockquote><p>定義：</p><ol><li>最大堆積：為一完備二元樹，任一節點的資料內容不小於其子節點的資料內容。</li><li>最小堆積：為一完備二元樹，任一節點的資料內容不大於其子節點的資料內容。</li></ol></blockquote><p>堆積因為其特性，發展出「堆積排序(Heap Sort)」及「優先佇列(Priority Queue)」等。以下運用陣列表示完備二元樹的方式來操作以下兩種動作，假設現在有一最大堆積，存放於陣列A<!-- -->[1]<!-- -->~A<!-- -->[n]<!-- -->中：</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="新增資料x">新增資料x<a class="hash-link" href="#新增資料x" title="Direct link to heading">​</a></h4><ol><li>為維持樹符合完備二元樹之定義（白話文：有缺一定在右下角），先將資料加在最後一節點註標之後（註標i=n+1），將x放在A<!-- -->[i]<!-- -->。</li><li>再來為了維持「父節點必須大於子節點」之特性，逐一向上檢查i與父節點(i/2)的大小關係是否需要調換位置，直至檢查到最上面的兒子（root下一層）。</li></ol><div class="codeBlockContainer_I0IT language-c++ theme-code-block"><div class="codeBlockContent_wNvx c++"><pre tabindex="0" class="prism-code language-c++ codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">#define maxsize 100</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int n,i;//n is number of elements in heap</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int heap[maxsize];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void InsertHeap(int x)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{   if(n==maxsize) HeapFull();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {   n++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        i=n;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while((i&gt;1)&amp;&amp;(x&gt;heap[i/2]))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {   heap[i]=heap[i/2];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            i/=2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }heap[i]=x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="刪除資料xx為堆積中最大值root">刪除資料x（x為堆積中最大值=root）<a class="hash-link" href="#刪除資料xx為堆積中最大值root" title="Direct link to heading">​</a></h4><ol><li>取出root資料後，會剩下兩個最大堆積，將最後一節點n資料拿到root存放，此時畢定不符合最大堆積定義。</li><li>從樹根出發，選取其子節點中較大者比較，若父節點大於子節點則終止；否，則交換，一直持續到找到樹葉節點為止。</li></ol><div class="codeBlockContainer_I0IT language-c++ theme-code-block"><div class="codeBlockContent_wNvx c++"><pre tabindex="0" class="prism-code language-c++ codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">//其餘設定承上面範例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int x,i,j;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int DeleteHeap()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(n==0) HeapEmpty();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {   x = heap[1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        heap[1]=heap[n];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        n--;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        i=1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(i&lt;=n/2)//持續尋找直到找到樹葉節點</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(heap[2*i]&gt;heap[2*i+1]) j=2*i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else j=2*i+1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(heap[j]&lt;heap[i]) break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                SWAP(&amp;heap[j],&amp;heap[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                i=j;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }return x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/yehs1225/yehs1225.github.io/docs/DataStructures/Tree.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_foO9"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/DataStructures/Sorting排序"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Sorting排序</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/Django/[DJ]Deploy"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Deploy</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#樹的概念" class="table-of-contents__link toc-highlight">樹的概念</a><ul><li><a href="#專有名詞" class="table-of-contents__link toc-highlight">專有名詞</a></li></ul></li><li><a href="#樹的表示方法" class="table-of-contents__link toc-highlight">樹的表示方法</a><ul><li><a href="#一般化串列表示法gernalized-list" class="table-of-contents__link toc-highlight">一般化串列表示法(gernalized list)</a></li><li><a href="#左子右兄弟表示法" class="table-of-contents__link toc-highlight">左子右兄弟表示法</a></li><li><a href="#分支度為2的表示法" class="table-of-contents__link toc-highlight">分支度為2的表示法</a></li></ul></li><li><a href="#二元樹" class="table-of-contents__link toc-highlight">二元樹</a><ul><li><a href="#二元樹表示法" class="table-of-contents__link toc-highlight">二元樹表示法</a></li></ul></li><li><a href="#二元樹走訪" class="table-of-contents__link toc-highlight">二元樹走訪</a></li><li><a href="#二元搜尋樹binary-search-tree" class="table-of-contents__link toc-highlight">二元搜尋樹(binary search tree)</a></li><li><a href="#heap-堆積" class="table-of-contents__link toc-highlight">Heap 堆積</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Tzu Hsuan Yeh. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.beb046ae.js"></script>
<script src="/assets/js/main.5c1be6b3.js"></script>
</body>
</html>