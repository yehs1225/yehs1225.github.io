<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Yeh&#39;s blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Yeh&#39;s blog Atom Feed"><title data-react-helmet="true">Graph圖形 | Yeh&#x27;s blog</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://your-docusaurus-test-site.com/docs/DataStructures/Graph"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Graph圖形 | Yeh&#x27;s blog"><meta data-react-helmet="true" name="description" content="圖形是包含點和連接點的邊，所組成的離散結構。可用來描述許多實際問題。"><meta data-react-helmet="true" property="og:description" content="圖形是包含點和連接點的邊，所組成的離散結構。可用來描述許多實際問題。"><link data-react-helmet="true" rel="icon" href="/img/favicon.png"><link data-react-helmet="true" rel="canonical" href="https://your-docusaurus-test-site.com/docs/DataStructures/Graph"><link data-react-helmet="true" rel="alternate" href="https://your-docusaurus-test-site.com/docs/DataStructures/Graph" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://your-docusaurus-test-site.com/docs/DataStructures/Graph" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.f2b17ad4.css">
<link rel="preload" href="/assets/js/runtime~main.bfbdacdc.js" as="script">
<link rel="preload" href="/assets/js/main.e193f680.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/favicon.png" alt="My Site Logo" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/favicon.png" alt="My Site Logo" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">My Site</b></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/intro">Notes</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/yehs1225" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">🌜</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">🌞</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_P2Lg"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_rKC_"><div class="sidebar_CW9Y"><nav class="menu thin-scrollbar menu_SkdO"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">Notes Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/Algorithm/Algorithm[1]">Algorithm</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/BasicKnowlege/CSS-RWD切版練習">BasicKnowlege</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active hasHref_VCh3" aria-current="page" href="/docs/DataStructures/Graph">DataStructures</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/DataStructures/Graph">Graph圖形</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/DataStructures/Recursion">Recursion</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/DataStructures/Sorting排序">Sorting排序</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/DataStructures/Tree">Tree</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/Django/Build a CRM with Django">Django</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/JavaScript/JavaScript-this">JavaScript</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/Reactjs/React_ES6">Reactjs</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/Tools/Command-Line-and-Vim">Tools</a></div></li></ul></nav></div></aside><main class="docMainContainer_TCnq"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="docItemContainer_vinB"><article><div class="tocCollapsible_jdIR theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_Fzxq">On this page</button></div><div class="theme-doc-markdown markdown"><h1>Graph圖形</h1><p>圖形是包含點和連接點的邊，所組成的離散結構。可用來描述許多實際問題。
圖形Graph是非常廣泛使用的資料結構，許多常見問題可用「點」(vertex)和「邊」(edge)，描繪出對應的「圖形表示法」(graph representation)。如此一來，圖形理論(graph theory)上的許多性質可被用來解決所轉換的問題。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="問題的圖形表示法">問題的圖形表示法<a class="hash-link" href="#問題的圖形表示法" title="Direct link to heading">​</a></h2><p>幾個著名且可用圖形描繪的問題。</p><ul><li><h4 class="anchor anchorWithStickyNavbar_mojV" id="尤拉迴路eulerian-circuit">尤拉迴路(Eulerian Circuit)<a class="hash-link" href="#尤拉迴路eulerian-circuit" title="Direct link to heading">​</a></h4><p>​		西元1763年，尤拉利用圖形來描繪東普魯是柯尼斯堡的「七橋問題」(圖1)，圖中有ABCD四塊陸地及七座橋聯絡，七橋問題即盼望能走訪各城市僅經過所有橋一次。將圖1轉以圖形表示法即為圖2，同時定義原七橋問題欲尋覓的方法，<strong>「尤拉迴路(Euler tour(circuit))」</strong>: 自某頂點出發，走過所有邊恰好一次，最後回到出發點；<strong>「尤拉路徑(Eulerian path(walk))」</strong>: 則表示起點及終點不必相同。</p><p>​		尤拉證明 : 『相連圖形上存在尤拉迴路，若且唯若每一頂點的分支度(degree)皆為偶數』且『相連圖形上存在尤拉路徑，若且唯若且有兩個(或沒有)頂點分支度為奇數，其餘皆為偶數』。七橋問題不存在尤拉迴路及尤拉路徑，無解。此種轉換問題以點及邊表示的抽象技巧，奠定了圖論研究的基礎。  </p><p><img src="/assets/images/Graph1-55d1a7dffc96e8361952f0c0fc8261a3.jpg" width="1926" height="722"></p></li><li><h4 class="anchor anchorWithStickyNavbar_mojV" id="漢米爾頓迴圈hamiltonian-cycle">漢米爾頓迴圈(Hamiltonian Cycle)<a class="hash-link" href="#漢米爾頓迴圈hamiltonian-cycle" title="Direct link to heading">​</a></h4><p>漢米爾頓提出一個問題 : 在十二面體中，若每一頂點代表一城市，能否走過每一城市恰巧一次，且回到原出發城市(即此點會經過兩次)。此問題與尤拉迴路類似，差異在於尤拉迴路是希望走過每個「邊」一次(以迴路(Circuit)描述此類問題)；此問題則是著重在「點」(以迴圈(Cycle)描述)，且這類問題屬於NP-complete的問題。</p></li><li><h4 class="anchor anchorWithStickyNavbar_mojV" id="旅行銷售員問題travel-salesman-problem">旅行銷售員問題(Travel Salesman problem)<a class="hash-link" href="#旅行銷售員問題travel-salesman-problem" title="Direct link to heading">​</a></h4><p>TSP問題希望能走訪每一個點一次，同時追求總成本(距離或時間等)要最小。求解此問題等同於在對應圖形上找到成本總和最小的漢米爾頓迴圈。</p></li><li><h4 class="anchor anchorWithStickyNavbar_mojV" id="頂點覆蓋問題vertex-cover">頂點覆蓋問題(Vertex Cover)<a class="hash-link" href="#頂點覆蓋問題vertex-cover" title="Direct link to heading">​</a></h4><p>在博物館中有許多以兩頂點連成的邊作為走道，希望在最少的頂點處安裝監視器監視其所連接的走道(或公園內放置最少的燈，讓人至少可看到亮光)。轉換成圖形可如此描述：挑選最少的頂點，使得任何一邊的兩個頂點中，至少有一頂點在所挑的集合中。以圖3來說，AC及DBE是兩組可行的解，而AC這組姐所需較少頂點，且沒有更少個數的解，齊集唯頂點覆蓋問題的解。</p><p><img src="/assets/images/Graph2-68cb98ffe7338b0fec2a346a9724fb6b.jpg" width="1480" height="468"></p></li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="專有名詞">專有名詞<a class="hash-link" href="#專有名詞" title="Direct link to heading">​</a></h2><p>常用G=(V,E)描述圖形，其中V是包含所有頂點的有限集合，E是連接V中頂點的邊所構成的集合；V={v1,v2,...,vn}，E={e1,e2,...,em}，n&gt;0，m≧0。</p><ul><li><h4 class="anchor anchorWithStickyNavbar_mojV" id="無向圖有向圖">無向圖、有向圖<a class="hash-link" href="#無向圖有向圖" title="Direct link to heading">​</a></h4><ul><li><p>無向圖(undirected graph)</p><p>e=(v1,v2)，(v1,v2)和(v2,v1)代表相同的邊。</p><blockquote><p>樹(Tree)是圖形的部分集合。</p></blockquote></li><li><p>有向圖(directed graph)</p><p>e=(v1,v2)，v1為頭(head)；v2為尾(tail)，(v1,v2)和(v2,v1)不是相同的邊。</p></li></ul></li></ul><p>​			在這裡討論的圖若無特別指明指的是無向圖，且討論的圖有下列限制：</p><ol><li><p>圖形中任何頂點不允許有連接自己的邊，亦即沒有(v,v)、(u,u)的邊。</p><p>=&gt; 無限制則稱為「自我迴圈(self-loop)」</p></li><li><p>圖形中的邊不得重複。</p><p>=&gt; 無限制則稱為「多邊圖(multigraph)」</p><p><img src="/assets/images/Graph3-e16338acf24642d5635fd33fed370765.jpg" width="1480" height="450"></p></li></ol><ul><li><h4 class="anchor anchorWithStickyNavbar_mojV" id="完備圖">完備圖<a class="hash-link" href="#完備圖" title="Direct link to heading">​</a></h4><p>在有n個頂點的無向圖中，至多有n(n-1)/2條邊。若該圖形確實有n(n-1)/2條邊，則稱為<strong>完備圖(Complete graph)</strong>。</p><p>而有向圖至多有n(n-1)條邊，若符合則稱為有向完備圖。</p></li><li><h4 class="anchor anchorWithStickyNavbar_mojV" id="相鄰連接分支度">相鄰、連接、分支度<a class="hash-link" href="#相鄰連接分支度" title="Direct link to heading">​</a></h4><p>G = ( V , E )。</p><ul><li>若(u,v) ∈ E ，則 u和v「相鄰」(adjacent)；且(u,v)「連接」(incident on)  u 和 v。</li><li>若G有方向性，而&lt; u , v &gt;∈ E ，則稱u「相鄰至」 (adjacent to) v；且v從u相鄰(adjacent from)；&lt; u , v &gt;連接u、v。</li><li>所有連接在無向圖頂點u上的總邊數，稱為u的「分支度」(degree)。</li><li>在有向圖中，可分為out-degree及in-degree。</li></ul></li><li><h4 class="anchor anchorWithStickyNavbar_mojV" id="子圖">子圖<a class="hash-link" href="#子圖" title="Direct link to heading">​</a></h4><p>G = ( V , E ) 的子圖 G&#x27; = ( V&#x27; , E&#x27; )須滿足 V&#x27; ∈ V 且 E&#x27; ∈ E&#x27;  。</p></li><li><h4 class="anchor anchorWithStickyNavbar_mojV" id="路徑簡單路徑長度迴圈">路徑、簡單路徑、長度、迴圈<a class="hash-link" href="#路徑簡單路徑長度迴圈" title="Direct link to heading">​</a></h4><ul><li>u到v的路徑(path)是由頂點u-v1-v2-...vi,v及其連接的邊(u,v1),(v1,v2),...,(vi,v)所構成(或&lt;u,v1&gt;,&lt;v1,v2&gt;,...,&lt;vi,v&gt;)，以u-v1-v2-...-v表示此u到v的路徑。</li><li>簡單路徑(simple path)指的是除了起終點外，其他頂點皆不同的路徑。</li><li>迴圈(cycle)指的是起終點相同的簡單路徑。</li></ul><ol><li>圖5 ，A-B-C-D是一長度為3的簡單路徑</li><li>圖5 ，A-B-C-D-B是一長度為4的路徑，但不是簡單路徑</li><li>圖5 ，A-B-D-C-A 是一長度為4的迴圈</li></ol><p><img src="/assets/images/Graph4-5eba2f35520d54e11070cc03a8f193f8.jpg" width="1479" height="528"></p></li><li><h4 class="anchor anchorWithStickyNavbar_mojV" id="相連的頂點或圖形相連組合">相連的頂點(或圖形)、相連組合<a class="hash-link" href="#相連的頂點或圖形相連組合" title="Direct link to heading">​</a></h4><p>無向圖形G = ( V , E ) 。頂點u存在一路徑連接到頂點v，則稱頂點u和v是相連的(connected)。</p><p>無向圖形G的相連組合(connected component) C指的是圖中最大的相連子圖，亦即C是G的相連子圖中最大的。</p></li><li><h4 class="anchor anchorWithStickyNavbar_mojV" id="強固相連強固相連組合">強固相連、強固相連組合<a class="hash-link" href="#強固相連強固相連組合" title="Direct link to heading">​</a></h4><p>有向圖形G = ( V , E ) 中，任兩點u、v，都存在兩條路徑 : 頂點u存在一路徑連接到頂點v，且頂點v存在一路徑連接到頂點u，則稱為強固相連(strongly connected)。強固相連組合(strongly connected component)為有向圖中最大且強固相連的子圖。</p></li><li><h4 class="anchor anchorWithStickyNavbar_mojV" id="沒有迴圈">沒有迴圈<a class="hash-link" href="#沒有迴圈" title="Direct link to heading">​</a></h4></li></ul><p>​		不存在迴圈的圖形稱為「沒有迴圈」(acyclic)，一棵樹即為相連且沒有迴圈的圖形。由此可知圖		形graph是比樹tree更為一般化的資料結構，因此在對樹所做的動作運算皆可在圖形上探索。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="圖形的資料表示">圖形的資料表示<a class="hash-link" href="#圖形的資料表示" title="Direct link to heading">​</a></h2><p>圖形是比樹更為一般化的資料結構，因此之前對樹所做的運算皆可在圖形執行。此介紹兩種常見的圖形資料結構「相鄰矩陣」、「相鄰串列」。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="相鄰矩陣adjacent-matrix">相鄰矩陣(adjacent matrix)<a class="hash-link" href="#相鄰矩陣adjacent-matrix" title="Direct link to heading">​</a></h3><p>將頂點是否有相鄰的關係記錄在矩陣中。若G = ( V , E )，而|V|=n，即G有n個頂點。用一個n x n的二維矩陣A表示 : 令i,j ∈ V,若(i,j)∈E (或&lt;i,j&gt;∈E )，則Aij= 1，否則Aij=0。</p><p>根據上面敘述，可知相鄰矩陣是由0和1所組成。且無向圖形的相鄰矩陣是對稱的(即Aij=Aji)；有向圖形則未必。另外，可計算其分支度：</p><p>無向圖形 : <code>d(i) = ΣAij (j from 0~n-1)   </code></p><p>有向圖形 : <code>dout(i) = ΣAij (j from 0~n-1)</code> 、<code>din(i) = ΣAji (j from 0~n-1)</code> </p><p>以矩陣解決圖形問題為O(n^2)，若矩陣為稀疏矩陣(sparse)，可以用相鄰串列表示。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="相鄰串列adjacent-list">相鄰串列(adjacent list)<a class="hash-link" href="#相鄰串列adjacent-list" title="Direct link to heading">​</a></h3><p>G = ( V , E )，且|V|=n，G中的一頂點u的分支度為k，則可以將與u相鄰的k個頂點用鏈節串列串起，如此一來，n個頂點就會有n個鏈節串列。如圖6所示，以head指標指向每個頂點，每個頂點在各自串起有連結的頂點；其中，因為n個頂點是勢必不可省略的，因此用方便定址的陣列來宣告head，以方便用頂點編號作為陣列註標。</p><p><img src="/assets/images/Graph5-314e849775ea7de77195b36e3fddadfa.jpg" width="1234" height="490"></p><div class="codeBlockContainer_I0IT language-c++ theme-code-block"><div class="codeBlockContent_wNvx c++"><pre tabindex="0" class="prism-code language-c++ codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">#define n 20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  int data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  struct Node *link;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Node *head[n];</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>若無向圖形有n個點，e條邊，則相鄰串列需要(n+2e)個儲存空間。</p><p>Q : 如何得知一給定圖形有多少條邊呢?</p><p>A1:以相鄰矩陣儲存，則查看有多少1，為O(n^2)</p><p>A2:以相鄰串列儲存，則走訪所有節點，為O(n+2e)</p><p><strong>效率和圖形的疏密程度有關</strong></p><p>對有向圖形而言，要得知向外分支度時，只需走訪該頂點串列，為O(n+e)。然而要計算向內分支度時，以圖6的形式則較不直覺，因此可再設計反向相鄰串列(inverse adjacent list)來表示，如圖7。</p><p><img src="/assets/images/Graph6-701b31b6cd98ac9b72438977214a0fc1.jpg" width="1234" height="490"></p><h2 class="anchor anchorWithStickyNavbar_mojV" id="ssad---single-source--all-destination">SSAD - Single source / All destination<a class="hash-link" href="#ssad---single-source--all-destination" title="Direct link to heading">​</a></h2><blockquote><p><strong>單一起點至所有目的地的最短路徑</strong>：給予一有向圖形，圖中的邊都是非負的成本，尋找最短路徑。</p></blockquote><p><strong>Dijkstra 演算法</strong></p><div class="codeBlockContainer_I0IT language-pseudocode theme-code-block"><div class="codeBlockContent_wNvx pseudocode"><pre tabindex="0" class="prism-code language-pseudocode codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">Input : weighted graph G = (V,E), V={0,1,2,...,n-1}，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        edge cost w[i,j], i,j∈V , origin u</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Output : the shortest path from u to v</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//初始化u到所有目的地v</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for (v=0;v&lt;n;v++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    D[v] = w[u,v]; //D[v] : u到v目前最短距離</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    C[v] = u; //u到v的最短距離是經由u提供</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">found[u] = true; D[u] = 0;//u到u的最短距離已被找到，其距離為0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">while (還有目的地的最短距離未被找到)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    k = min{v|D[v]為最小且found[v]為false};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    found[k]=true; //u到k的最短距離已被決定</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for(v=0;v&lt;n;v++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(!found[v] &amp;&amp; D[k]+w[k][v]&lt;D[v])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            D[v] = D[k]+w[k][v];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            C[v] = k; //u到v的最短路徑包含(k,v)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">output the shortest path from u to v //D[v]，v∈V,u≠v//利用C[v]追朔u-v的最短路徑 </span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><strong>印出 u-v的最短路徑</strong></p><div class="codeBlockContainer_I0IT language-c++ theme-code-block"><div class="codeBlockContent_wNvx c++"><pre tabindex="0" class="prism-code language-c++ codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">String ShortestPath(int u,int v)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String path = IntToStr(v);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while(C[v]!=u)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        path = IntToStr(C[v])+&quot;--[&quot;+IntToStr(w[C[v]][v])+&quot;]&quot;+&quot;--&gt;&quot;+path;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        v = C[v];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return path;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="all-pairs">All Pairs<a class="hash-link" href="#all-pairs" title="Direct link to heading">​</a></h2><p>概念：每次加入一個點，如果他對任何兩點間的距離有幫助就加入。</p><div class="codeBlockContainer_I0IT language-c++ theme-code-block"><div class="codeBlockContent_wNvx c++"><pre tabindex="0" class="prism-code language-c++ codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">Input : Graph G=(V,E)，V={0,1,2,..n-1}和其相鄰矩陣w[i][j]，0≦i,j&lt;n。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Output : 任兩點間的最短距離矩陣A</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for(int i=0;i&lt;0;i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for(int j=0;j&lt;0;j++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        A[i][j]=w[i][j];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for (int k=0;k&lt;n;k++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for(int i=0;i&lt;n;i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int j=0;j&lt;n;j++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(A[i][j]&lt;A[i][k]+A[k][j])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                A[i][j]=A[i][j]&lt;A[i][k]+A[k][j]?A[i][j]:A[i][k]+A[k][j]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="search">Search<a class="hash-link" href="#search" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="dfs深先搜尋">DFS深先搜尋<a class="hash-link" href="#dfs深先搜尋" title="Direct link to heading">​</a></h3><p>遞迴</p><div class="codeBlockContainer_I0IT language-c++ theme-code-block"><div class="codeBlockContent_wNvx c++"><pre tabindex="0" class="prism-code language-c++ codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">Input:Graph G=(V,E)，V={0,1,2,..n-1}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Output:G的深先搜尋順序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int visited[n];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void DFS(int u)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    visited[u]=1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print u;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for(所有與u相鄰的頂點v)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(v未曾走訪，即visited[v]!=1) DFS(v);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">main()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for(int i=0;i&lt;n;i++) visited[i]=0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    DFS(0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>堆疊</p><div class="codeBlockContainer_I0IT language-c++ theme-code-block"><div class="codeBlockContent_wNvx c++"><pre tabindex="0" class="prism-code language-c++ codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">Input:Graph G=(V,E)，V={0,1,2,..n-1}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Output:G的深先搜尋順序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int visited[n];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void DFS(int u)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{   push(u);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while(stack is not empty)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {   v=pop();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print v;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        visited[v]=1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(w為v尚未走訪的相鄰頂點，即visited[w]!=1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           push(w);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="bfs廣先搜尋">BFS廣先搜尋<a class="hash-link" href="#bfs廣先搜尋" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_I0IT language-pseudocode theme-code-block"><div class="codeBlockContent_wNvx pseudocode"><pre tabindex="0" class="prism-code language-pseudocode codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">Input:Graph G=(V,E)，V={0,1,2,..n-1}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Output:G的廣先搜尋順序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int visited[n];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">main()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for(int i=0;i&lt;n;i++) visited[i]=0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    visited[0]=1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    AddQ(0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while(Q仍有頂點資料)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int u = Delete_Q;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print u;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(所有與u相鄰的頂點v)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(v未曾走訪，即visited[v]!=1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                visited[v] = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                AddQ(v);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/yehs1225/yehs1225.github.io/docs/DataStructures/Graph.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_foO9"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/BasicKnowlege/網路基礎"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">網路基礎</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/DataStructures/Recursion"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Recursion</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#問題的圖形表示法" class="table-of-contents__link toc-highlight">問題的圖形表示法</a></li><li><a href="#專有名詞" class="table-of-contents__link toc-highlight">專有名詞</a></li><li><a href="#圖形的資料表示" class="table-of-contents__link toc-highlight">圖形的資料表示</a><ul><li><a href="#相鄰矩陣adjacent-matrix" class="table-of-contents__link toc-highlight">相鄰矩陣(adjacent matrix)</a></li><li><a href="#相鄰串列adjacent-list" class="table-of-contents__link toc-highlight">相鄰串列(adjacent list)</a></li></ul></li><li><a href="#ssad---single-source--all-destination" class="table-of-contents__link toc-highlight">SSAD - Single source / All destination</a></li><li><a href="#all-pairs" class="table-of-contents__link toc-highlight">All Pairs</a></li><li><a href="#search" class="table-of-contents__link toc-highlight">Search</a><ul><li><a href="#dfs深先搜尋" class="table-of-contents__link toc-highlight">DFS深先搜尋</a></li><li><a href="#bfs廣先搜尋" class="table-of-contents__link toc-highlight">BFS廣先搜尋</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Tzu Hsuan Yeh. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.bfbdacdc.js"></script>
<script src="/assets/js/main.e193f680.js"></script>
</body>
</html>